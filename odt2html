#! /usr/bin/python
# encoding=utf-8
# odt2html
# Copyright 2014, Trinity College Computing Center
# Written by David Chappell
# Last modified: 23 May 2014

#=============================================================================
# To the User
#=============================================================================
#
# This program converts Opendocument word-processing files such as those 
# produced by Openoffice into HTML format. It can also produce EPUB files
# which are XHTML files packed into a zip archive with some index and
# metadata files.
#
# == Usage ==
# 
# odt2html [--debug] [--force] [--epub] <filename.odt>...
#
# Each ODT file is converted to a single HTML or EPUB file. The output
# file will have the same base name and will be placed in the same 
# directory. If the output file already exists and is newer than the
# input file, then that file will be skipped unless the --debug or 
# --force option was used.
#
# == Preparing Documents for Conversion ==
#
# This program is designed as part of a document preparation workflow to
# produce high-quality HTML files from robustly-formatted Opendocument
# word-processing files. Fragile formatting which would break of the font
# or margins were changed will also break when the document is converted
# to HTML. Some examples of formatting problems which you should correct:
#
# * This program needs to know your document's title. It will look first
#   in the metadata (go to File->Properties and look under the Description
#   tab). If the title there is blank, it will look for level 1 headings
#   and take the first one as the title. If there are no level 1 headings,
#   the program will stop.
#
# * Tabs for formatting tabular data are not supported in HTML. This
#   converter will insert a few spaces for each tab, but unless the tabs
#   are used for indenting the start of a line, things will not line up
#   as you wished. Replace tabbed tables with actual tables. You can turn
#   the borders off if you wish.
#
# * Extra spaces which may have been inserted to adjust line breaking will
#   probably not work in the HTML version. Even if it does, it will break
#   when the window size is adjusted. Instead insert an explicit line break
#   or use non-breaking spaces to prevent a line break at an undesireable
#   place.
#
# * Likewise, extra carriage returns (empty paragraphs) inserted to move a
#   page break will cause problems. There are no pages in a web browser
#   window and the extra space will be a visual distraction. Go into
#   paragraph formatting and in the Text Flow tab put a checkmark next to
#   "Keep with next paragraph". This not only get rid of the spurious
#   vertical space, but it will fix the bad break permanently in the print
#   and PDF versions.
#
# * If you have indented single-line paragraphs using spaces or tabs, perhaps
#   to represent a verse from a poem, you should reformat them to use a left
#   margin. Otherwise when the lines are wrapped on a narrow display, they
#   may become difficult to read. You may want to use a hanging indentation.
#
# * Watch out for superscripts and subscripts. In Openoffice there are
#   ways to put regular text inside a span of superscript or subscript
#   text. This will not work in HTML. Writing code to unnest the spans
#   would be tricky, so we just warn you about it and expect you to fix
#   it in the source document. Select the text in question, chose 
#   Format->Clear Direct Formatting, and then select the parts which should
#   be superscripts or subscripts and again format them as such.
#
# If you correct these problems you will get an HTML version which is
# reasonably close to the printed or PDF version. But unlike the PDF
# version it will be reflowed to suit the size of the viewer's window.
# This generally works so well that documents originally formatted for
# US Letter paper can be read conformatly on the screen of a smartphone.
#
# A few CSS tricks improve reading on small screens. For one, the margins
# are cut from 1/2" to 1/8" for narrow screens. Second, multi-column layout
# is disabled for narrow screens.
#
# == Inter-Document Hyperlinks ==
#
# If you create hyperlinks between documents in a set and then convert them
# all to HTML using this program, the hyperlinks will be converted to link
# the HTML versions.
#
# == Master Documents ==
#
# To convert a master document, first export it as an ODT file and convert
# that.
#
# Hyperlinks between the subdocuments of a master document will be converted
# to internal links within the final document.
#
# == Supported ODF Features ==
# * Headings
# * Paragraph indentation
# * Font changes including family, weight, slant, superscript, subscript
# * Text color (forground and background)
# * Tables with borders and padding
# * Lists
# * Hyperlinks
# * Raster images in JPEG, GIF, and PNG formats
# * SVG drawings
#
# == What is not Yet Supported ==
# * Page background color
#
# == What I Do Not Intend to Support ==
# * Openoffice drawings
#

#=============================================================================
# Programmer's Notes
#=============================================================================
#
# == Opendocument ==
# * https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=office
# * http://docs.oasis-open.org/office/v1.2/OpenDocument-v1.2-part1.html
#
# == Python Elementtree ==
# * https://docs.python.org/2/library/xml.etree.elementtree.html
# * http://lxml.de/
# * http://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree/
#
# == Epub ==
# * http://www.manuel-strehl.de/dev/simple_epub_ebooks_with_python.en.html
# * https://code.google.com/p/python-epub-builder/
#
# == TODO ==
# * Convert List styles
# * Implement document background color
# * Figure out what bookmarks are and whether we should implement them
# * Drop page numbers from table of contents
# * Test with weird files from Google Docs

import zipfile
import sys
import os
import lxml.etree as ET
from lxml.builder import E
import urllib
import re
import textwrap
import uuid

#============================================================================
# ODT to HTML Converter
#============================================================================
class Odt2Html(object):
	def __init__(self, odt_filename, output_filename, output_format, debug):
		self.odt_filename = odt_filename
		self.debug = debug

		self.keep_unused_styles = False
		self.use_data_urls = True
		self.keep_toc = True
		self.simplify_table_borders = True
		self.font_support_level = 1	# 0: weight and slant, 1: generic families, 2: specific families
		self.collapse_styles = True
		self.topsects_as_files = False

		self.depth = 0				# recursion level
		self.section_count = 0		# current top-level section
		self.subdocs_by_href = {}	# sections which represent child documents
		self.title = None			# document title
		self.h1s = []				# level 1 headings
		self.images = []			# images to include in .epub file

		if output_format == "html":
			self.load_and_convert()
			self.add_dlbox()
			self.save_html(output_filename)
		elif output_format == "epub":
			self.use_data_urls = False
			self.keep_toc = False
			self.topsects_as_files = True
			self.load_and_convert()
			self.save_epub(output_filename)
		else:
			raise Exception

	#============================================================================
	# Load the style and content XML files into memory and create most of the
	# output HTML document in memory.
	#============================================================================
	def load_and_convert(self, data_urls=True):
		# Open the ODT file and show what is inside it
		self.odt = zipfile.ZipFile(self.odt_filename)
		if self.debug:
			print "===== ODT File Contents ====="
			for resource_filename in self.odt.namelist():
				print "  %s" % resource_filename
			print

		# Uncompress and parse the XML streams which we need.
		styles_xml = self.load_xml("styles.xml")
		content_xml = self.load_xml("content.xml")
		meta_xml = self.load_xml("meta.xml")

		# Parse the styles from styles.xml and content.xml
		self.styles = OdtStyle2Css(
			self.debug,
			self.keep_unused_styles,
			self.collapse_styles,
			self.simplify_table_borders,
			self.font_support_level
			)
		for font_face_decls in (
			styles_xml.xpath("/document-styles/font-face-decls")[0],
			content_xml.xpath("/document-content/font-face-decls")[0],
			):
			self.styles.add_fonts(font_face_decls)
		for stylesheet in (
			styles_xml.xpath("/document-styles/styles")[0],				# from stylesheet UI
			#styles_xml.xpath("/document-styles/automatic-styles")[0],	# used in master styles
			content_xml.xpath("/document-content/automatic-styles")[0]	# from element format UI
			):
			self.styles.add_stylesheet(stylesheet)

		# Create HTML objects into which we can start
		# to insert objects to represent the output document
		self.html_head = E.head()
		self.html_head.append(E.meta({"http-equiv":"content-type","content":"text/html; charset=utf-8"}))
		self.html_body = E.body()

		# Search for the title of the document
		titles = meta_xml.xpath("/document-meta/meta/title")
		if len(titles) > 0 and titles[0].text is not None:
			self.title = titles[0].text
		else:
			#headings = content_xml.xpath("/document-content/body/text/h")
			headings = content_xml.xpath("/document-content/body/text//h")
			if len(headings) > 0:
				self.title = self.element_extract_text(headings[0])
		if self.title is None:
			raise OdfNotSupported("No document title")
		self.html_head.append(E.title(self.title))

		# Locate ODT document body
		odt_body = content_xml.xpath("/document-content/body/text")[0]

		# Pass 1
		self.section_count = 0
		for odt_el in odt_body:
			self.scan_element(odt_el)

		# Pass 2: convert the document and append it to the HTML body
		self.section_count = 0
		for odt_el in odt_body:
			self.convert_element(odt_el, self.html_body)

		# Convert the footer and add it to the body
		odt_footer = styles_xml.xpath("/document-styles/master-styles/master-page[@name='Standard']/footer/p")
		#print "footer:", odt_footer
		if len(odt_footer) >= 1:
			html_footer = E.div({"class":"footer"})
			self.convert_element(odt_footer[0], html_footer)
			self.html_body.append(html_footer)

		# Scan table cells and where they contain a single paragraph, subsume it.
		for td in self.html_body.xpath(".//td"):
			assert td.text is None, "unexpected text: \"%s\"" % td.text
			assert td.tail is None, "unexpected tail: \"%s\"" % td.tail
			if len(td) == 1 and td[0].tag == "p":
				p = td[0]
				classes = []
				if "class" in td.attrib:
					classes.append(td.attrib["class"])
				if "class" in p.attrib:
					classes.append(p.attrib["class"])
				if len(classes) > 0:
					td.attrib["class"] = " ".join(classes)
				td.text = p.text
				for child in p:
					td.append(child)
				td.remove(p)
				if td.text is None or len(td.text) < 25:		# unwrap short <td>'s
					td.tail = ""

	#============================================================================
	# Load one of the XML files embedded in the ODT file
	#============================================================================
	def load_xml(self, filename):
		if self.debug:	
			print "===== %s =====" % filename

		tree = ET.parse(self.odt.open(filename))

		# Strip namespace URIs from tag and attribute names
		for el in tree.iter():
			if isinstance(el, ET._Comment):
				continue
			el.tag = el.tag.split("}")[1]
			attrib = {}
			for name, value in el.attrib.items():
				short_name = name.split("}")[1]
				del el.attrib[name]
				el.attrib[short_name] = value

		if self.debug:
			# FIXME: may be able to use encoding="unicode" here and rop the decode()
			print ET.tostring(tree, pretty_print=True, encoding="utf-8").decode("utf-8")

		return tree

	#============================================================================
	# Load and strip an SVG file
	#============================================================================
	def read_svg(self, filename, pretty_print=True):
		tree = ET.parse(self.odt.open(filename))
		for el in list(tree.iter()):
			self.svg_prune(el)
		# FIXME: may be able to use encoding="unicode" here and rop the decode()
		return ET.tostring(tree, pretty_print=pretty_print, encoding="utf-8").decode("utf-8")

	def svg_prune(self, element):
		for key in element.attrib.keys():
			if key.startswith("{http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd}"):
				del element.attrib[key]
			elif key.startswith("{http://www.inkscape.org/namespaces/inkscape}"):
				del element.attrib[key]
		for child in list(element):
			#print child.tag
			if child.tag.startswith("{http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd}"):
				element.remove(child)
			elif child.tag.startswith("{http://www.inkscape.org/namespaces/inkscape}"):
				element.remove(child)
			elif child.tag.startswith("{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"):
				element.remove(child)
			else:
				self.svg_prune(child)

	#============================================================================
	# Pass 1
	#============================================================================
	def scan_element(self, odt_el):
		# Collect the source file names of the subdocuments of a master document.
		# We need this information in order to resolve links between subdocuments.
		if odt_el.tag == "section":
			self.section_count += 1
			subdoc_href = self.get_section_source_href(odt_el)
			if subdoc_href is not None:
				#print "topsect%s" % self.section_count, subdoc_href
				self.subdocs_by_href[subdoc_href] = self.section_count

	# If this section encloses a subdocument of a master document,
	# return a href to the subdocument with the extension changed
	# to ".html".
	def get_section_source_href(self, odt_el):
		if odt_el.attrib.get("protected","false") != "true":
			return None
		section_sources = odt_el.xpath("./section-source")
		if len(section_sources) == 0:
			return None
		if len(section_sources) != 1:
			raise OdfInvalid("%d <section-source> elements" % len(section_sources))
		href = section_sources[0].attrib['href']
		return self.href_to_html(href)

	#============================================================================
	# This function converts an ODT element to HTML and adds it to the
	# parent HTML element specified. It then calls itself on each child
	# of the ODT element with the newly created HTML element as the 
	# target parent.
	#============================================================================
	def convert_element(self, odt_el, html_parent_el):
		convert_children = True

		if "style-name" in odt_el.attrib:
			style_name = odt_el.attrib['style-name']
		else:
			style_name = None

		if odt_el.tag == "sequence-decls":		# mystery
			html_el = None
		elif odt_el.tag == "section":
			if self.debug:
				print "  Section:", odt_el.attrib.get("name")
			html_el = E.div()
			if self.depth == 0:
				self.section_count += 1
				subdoc_href = self.get_section_source_href(odt_el)
				if subdoc_href:		# if this is a child of a master document,
					if self.section_count != self.subdocs_by_href[subdoc_href]:
						raise AssertionError
				html_el.attrib["id"] = "topsect%d" % self.section_count
		elif odt_el.tag == "section-source":	# handled during pass 1
			html_el = None
		elif odt_el.tag == "h":
			if self.debug:
				print "  Heading:", self.element_extract_text(odt_el), style_name
			level = int(odt_el.attrib['outline-level'])
			html_el = E("h%d" % level)
			if level == 1:	# level 1 headings have ID's

				if style_name.startswith("P"):
					raise AssertionError("Level 1 heading with paragraph style: %s" % style_name)

				bookmarks = odt_el.xpath("./bookmark-start")
				if len(bookmarks) > 0:
					h_id = bookmarks[0].attrib["name"]
				else:
					h_id = "subh%d" % (len(self.h1s) + 1)
				h_filename = "topsect%d.html" % self.section_count
				h_text = self.element_extract_text(odt_el)
				html_el.attrib['id'] = h_id
				self.h1s.append((h_filename, h_id, h_text))
		elif odt_el.tag == "bookmark":
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "bookmark-start":
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "bookmark-end":
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "p":					# paragraph
			# If this paragraph is the first one inside an <LI> tag, put everything
			# inside the <LI> instead since otherwise if the paragraph is indented
			# it will move away from the bullet.
			if html_parent_el.tag == "li" and self.element_empty(html_parent_el):
				html_el = html_parent_el
			else:
				html_el = E.p()
		elif odt_el.tag == "span":				# text format
			html_el = E.span()
			html_el.tail = ""					# <-- prevents newline with pretty_print=True
		elif odt_el.tag == "a":
			href = odt_el.attrib["href"]
			#print "  href: %s" % href
			if href.startswith("http:"):		# Internet
				pass
			elif href.startswith("ftp:"):		# Internet
				pass
			elif href.startswith("../"):		# relative to zip root (but outside)
				href_html = self.href_to_html(href)
				if href_html in self.subdocs_by_href:	# in same master document?
					if self.topsects_as_files:
						href = "topsect%s.html" % self.subdocs_by_href[href_html]
					else:
						href = "#topsect%s" % self.subdocs_by_href[href_html]
				else:
					# Make sure the file named (likely an ODT or HTML file) exists
					href = href[3:]
					fs_path = os.path.join(os.path.dirname(self.odt_filename), urllib.url2pathname(href))
					if os.path.exists(fs_path):
						print "  href: %s" % fs_path
					else:
						print "  Warning: broken link: %s" % fs_path
					# Whether it exists or not, point to the HTML version
					href = href_html[3:]
			elif href.startswith("#"):			# internal link
				pass
			else:
				raise OdfNotImplemented("unimplemented href: %s" % href)
			html_el = E.a({"href":href})
			html_el.tail = ""
		elif odt_el.tag == "line-break":
			html_el = E.br()
		elif odt_el.tag == "soft-page-break":	# FIXME: read up on this
			html_el = ET.Comment("soft-page-break")
		elif odt_el.tag == "tab":
			if len(odt_el) != 0:
				raise OdfInvalid("<tab> should not have children")
			html_el = E.span({"class":"tab"})
			html_el.text = 8 * u" "				# eight non-breaking spaces
		elif odt_el.tag == "s":					# spaces
			if len(odt_el) != 0:
				raise OdfInvalid("<s> should not have children")
			count = int(odt_el.attrib.get("c","1"))
			if count == 1:
				html_el = E.span({"dropme":"s"})
				html_el.text = " "
			else:
				html_el = E.span({"class":"space"})
				count = int(count * 1.15)		# 1.15 is fudge
				html_el.text = count * " "
		elif odt_el.tag == "table":
			html_el = E.table()
		elif odt_el.tag == "table-column":
			html_el = E.col()
		elif odt_el.tag == "table-header-rows":
			html_el = E.thead()
		elif odt_el.tag == "table-row":
			html_el = E.tr()
			style_name = None					# FIXME: table row style not implemented
		elif odt_el.tag == "table-cell":
			html_el = E.td()
			if "number-rows-spanned" in odt_el.attrib:
				html_el.attrib["rowspan"] = odt_el.attrib["number-rows-spanned"]
			if "number-columns-spanned" in odt_el.attrib:
				html_el.attrib["colspan"] = odt_el.attrib["number-columns-spanned"]
			if self.simplify_table_borders:
				style_name = None
		elif odt_el.tag == "covered-table-cell":
			html_el = None						# don't convert
		elif odt_el.tag == "list":
			html_el = E.ul()
			style_name = None					# FIXME: list style not implemented
		elif odt_el.tag == "list-header":
			raise OdfNotImplementedYet("list-header")
		elif odt_el.tag == "list-item":
			html_el = E.li()
		elif odt_el.tag == "frame":
			html_el = self.convert_frame(odt_el)
			html_el.attrib['style'] = "max-width:%s;max-height:%s" % (odt_el.attrib['height'], odt_el.attrib['height'])
			convert_children = False
		elif odt_el.tag == "page-number":		# FIXME: what about the content (which is an actual page number)?
			html_el = ET.Comment("page-number")
		elif odt_el.tag == "table-of-content":
			if self.keep_toc:
				html_el = E.div({"id":"toc"})
			else:
				html_el = None					# don't convert
		elif odt_el.tag == "table-of-content-source":
			html_el = None
		elif odt_el.tag == "index-body":
			html_el = E.div()
		elif odt_el.tag == "index-title":
			html_el = E.div()
		elif odt_el.tag == "user-defined":
			html_el = E.span({"class":"user-defined"})	# class is not used
		elif odt_el.tag == "variable-decls":	# FIXME: is this important?
			html_el = None	# drop children too
		elif odt_el.tag == "variable-set":		# FIXME: is this important?
			html_el = E.span({"dropme":odt_el.tag})
		else:									# unimplemented but not supressed
			#print "  Warning: unimplemented tag: %s" % odt_el.tag
			#html_el = E.span()
			raise OdfNotImplementedYet("unimplemented tag: %s" % odt_el.tag)

		if html_el is not None:
			if odt_el.text is not None:
				html_el.text = odt_el.text
			if odt_el.tail is not None:
				html_el.tail = odt_el.tail

			if style_name is not None:
				classname = self.styles.claim_style(style_name)
				if classname is not None:
					html_el.attrib['class'] = classname
				if self.styles.get_break_before(style_name) == "page":
					# Push a horizontal rule into the HTML body (not the parent).
					# We don't insert it into the parent because the heading which
					# causes the break could be inside a section which encloses
					# a subdocument and we want the page break to be before the
					# start of the section.
					if len(self.html_body) > 0:
						self.html_body.append(E.hr({"class":"pagebreak"}))

			if convert_children:
				# This function calls itself recursively to convert the children.
				for child in odt_el:
					self.depth += 1
					self.convert_element(child, html_el)
					self.depth -= 1

				# Now run through the children collapsing the unnecessary spans
				# which Google Docs creates for no appearent reason.
				prev_child = None
				for child in html_el:
					#print child, child.text, child.tail, child.attrib
					if prev_child is not None \
							and child.tag == "span" and prev_child.tag == "span" \
							and child.attrib == prev_child.attrib \
							and prev_child.text is not None \
							and (prev_child.tail is None or prev_child.tail == ""):
						#print "collapsed"
						prev_child.text += child.text
						if child.tail is not None:
							prev_child.tail = child.tail
						html_el.remove(child)

					else:
						prev_child = child
	
			# If a <P> tag is completely empty, put a <BR> tag into it because
			# in HTML 4 empty <P> tags are supposed to be ignored.
			if odt_el.tag == "p" and self.element_empty(html_el):
				#html_el = E.br()
				html_el.append(E.br())

			# If this is a table, create a <tbody> and move the non-header
			# rows into it. We have to do this to pass XHTML 1.1 validation.
			if html_el.tag == "table":
				tbody = E.tbody()
				for child in list(html_el):
					if child.tag == "tr":
						html_el.remove(child)
						tbody.append(child)
				html_el.append(tbody)

			# There are some empty ODF tags which we want to ignore, but we 
			# cannot ignore them completely because they can come inside runs
			# of text and we do not want to lose their tail text. Here we
			# merge their text and tail text into either the parent element or the 
			# previous sibling element and then drop them.
			if "dropme" in html_el.attrib:
				if len(html_el) > 0:
					raise OdfInvalid("<%s> tag not empty" % html_el.attrib["dropme"])
				text = ""
				if html_el.text is not None:
					text += html_el.text
				if html_el.tail is not None:
					text += html_el.tail
				if text != "":
					if len(html_parent_el) == 0:
						if html_parent_el.text is None:
							html_parent_el.text = ""
						html_parent_el.text += text
					else:
						prev_el = html_parent_el[-1]
						if prev_el.tail is None:
							prev_el.tail = ""
						prev_el.tail += text

			# If we haven't dropped this tag in the previous code block and we
			# have not subsuming it into its parent, add it to its parent
			# append it to its parent.
			elif html_el != html_parent_el:
				html_parent_el.append(html_el)

	def convert_frame(self, odt_frame):
		odt_image = odt_frame.xpath("./image")[0]
		href = odt_image.attrib['href']

		if href.endswith(".png"):
			mimetype = "image/png"
			compression = zipfile.ZIP_STORED
		elif href.endswith(".gif"):
			mimetype = "image/gif"
			compression = zipfile.ZIP_STORED
		elif href.endswith(".jpg"):
			mimetype = "image/jpeg"
			compression = zipfile.ZIP_STORED
		elif href.endswith(".svg"):
			mimetype = "image/svg+xml"
			compression = zipfile.ZIP_DEFLATED
		else:
			raise OdfNotImplemented("Href extension not recognized: %s" % href)

		# http://www.websiteoptimization.com/speed/tweak/inline-images/
		img = E.img({"alt":""})		# required for XHTML to validate
		if self.use_data_urls:
			if mimetype == "image/svg+xml":
				img_data = self.read_svg(href, pretty_print=False)
			else:
				img_data = self.odt.open(href, "r").read()
			print "  Data URL for %s: %d bytes" % (href, len(img_data))
			img.attrib['src'] = "data:%s;base64,%s" % (mimetype, urllib.quote(img_data.encode("base64")))
		else:
			img.attrib['src'] = href
			self.images.append((href, mimetype, compression))
		return img

	#============================================================================
	# Take the HTML BODY object in RAM, wrap it in an HTML element,
	# added a HEAD, and write it out to disk.
	#============================================================================
	def save_html(self, html_filename):
		self.html_head.append(E.meta({"name":"viewport","content":"width=device-width,initial-scale=1"}))

		# The base stylesheet for web browers
		css = textwrap.dedent("""\
			HTML, BODY, H1, H2, H3, H4, H4, P { margin: 0; padding: 0 }
			BODY { margin: 0.375in 0.125in 0.375in 0.125in; font-size: 12pt }
			@media (min-width: 8.5in) { BODY { margin: 0.5in } }
			H1, H2, H3, H4, H4 { font-size: inherit }
			TABLE { border-collapse: collapse }
			UL { margin: 0 }
			TH, TD { vertical-align: top }
			HR.pagebreak { margin: 0.5in -0.5in 0.5in -0.5in }
			SPAN.space { white-space: pre-wrap }
			DIV#dlbox { position: absolute; top: 0; right: 0; background-color: white }
			DIV#dlbox A { display: inline-block; width: 60pt; height: 15pt; font-size: 12pt; padding: 3pt; border-style: solid; border-color: black; border-width: 0 0 thin thin }
			@media print { DIV#dlbox { display: none } }
			DIV.footer { margin-top: 0.2in; font-size: 8pt }
			""")

		# Add the converted styles from the ODT document.
		css += "\n".join(self.styles.get_css(3.0))

		# Insert the CSS styles into the head of the document.
		style = E.style({"type": "text/css"})
		style.text = "\n" + re.sub(r"^", r"      ", css, flags=re.MULTILINE) + "\n    "
		self.html_head.append(style)

		# Write the HTML tree to a file
		outfh = open(html_filename, "w")
		outfh.write("<!DOCTYPE HTML>\n")
		html_elementtree = ET.ElementTree(element=E.html(self.html_head, self.html_body))
		html_elementtree.write(outfh, encoding="utf-8", pretty_print=True)

	# Add a box to the top-rigth corner of the document with links
	# to the PDF and ODT versions of this document.
	def add_dlbox(self):
		# Add links to top right
		dlbox = E.div()
		dlbox.attrib["id"] = "dlbox"
		basename = os.path.splitext(os.path.basename(self.odt_filename))[0]
		dlbox.append(E.a(u"Print PDF", {	# <-- space in non-breaking
			"title":"Download this page as a PDF file for high-quality printing",
			"href":"%s.pdf" % basename,
			"type":"application/pdf"
			}))
		dlbox.append(E.a(u"Edit ODT", {		# <-- space is non-breaking
			"title":"Download this page as an Opendocument word processing file",
			"href":"%s.odt" % basename,
			"type":"application/vnd.oasis.opendocument.text"
			}))
		dlbox[0].tail = ""		# supress newline after first </a> when pretty_print==True
		self.html_body.insert(0,dlbox)

	#============================================================================
	# Create an EPUB file. An EPUB file is a zip file containing:
	# * The document as one or more XHTML files
	# * Images
	# * An XML table of contents
	# * A few other metadata files
	#============================================================================
	def save_epub(self, epub_filename):
		epub = zipfile.ZipFile(epub_filename, 'w')
		epub_uuid = uuid.uuid4().urn

		# MIME type must be first in file and uncompressed
		epub.writestr("mimetype", "application/epub+zip", zipfile.ZIP_STORED)

		# Boilerplate
		epub.writestr("META-INF/container.xml", textwrap.dedent("""\
			<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
				<rootfiles>
					<rootfile full-path="content.opf" media-type="application/oebps-package+xml"/>
				</rootfiles>
			</container>
			"""), zipfile.ZIP_DEFLATED)

		# One copy of stylesheet
		epub.writestr("stylesheet.css", self.epub_css().encode("utf-8"), zipfile.ZIP_DEFLATED)

		#---------------------------------------------
		# Start building Content Index
		#---------------------------------------------
		index_tpl = ET.Element(
			"{http://www.idpf.org/2007/opf}package",
			{	"version": "2.0",
				"unique-identifier": "bookid",
				},
			nsmap = {
				None:"http://www.idpf.org/2007/opf",
				"dc":"http://purl.org/dc/elements/1.1/"
				},
			)

		# Metadata about the book
		metadata = E.metadata()
		index_tpl.append(metadata)
		metadata.append(E("{http://purl.org/dc/elements/1.1/}title",self.title))
		metadata.append(E("{http://purl.org/dc/elements/1.1/}identifier",epub_uuid,{"id":"bookid"}))
		metadata.append(E("{http://purl.org/dc/elements/1.1/}language","en-US"))

		# File which gives the book structure
		manifest = E.manifest()
		index_tpl.append(manifest)
		manifest.append(E.item({
			"id":"css",
			"href":"stylesheet.css",
			"media-type":"text/css",
			}))
		manifest.append(E.item({
			"id":"ncx",
			"href":"toc.ncx",
			"media-type":"application/x-dtbncx+xml",
			}))

		spine = E.spine({"toc":"ncx"})
		index_tpl.append(spine)

		#---------------------------------------------
		# Split previously generated HTML and save
		# in multiple files. Add them to the manifest
		# and spine.
		#---------------------------------------------

		self.html_head.append(E.link({"type":"text/css","rel":"stylesheet","href":"stylesheet.css"}))

		parts = []
		body = list(self.html_body)
		i = 0
		while len(body) > 0:
			chunk = E.body()
			chunk.append(body.pop(0))
			while len(body) > 0 and not (body[0].tag == "div" and body[0].attrib.get("id","").startswith("topsect")):
				chunk.append(body.pop(0))
		
			topsect_id = "topsect%d" % i
			topsect_filename = "topsect%d.html" % i	
			manifest.append(E.item({
				"id":topsect_id,
				"href":topsect_filename,
				"media-type":"application/xhtml+xml",
				}))
			spine.append(E.itemref({
				"idref":topsect_id
				}))

			html = E.html(self.html_head, chunk)
			html.attrib['xmlns'] = 'http://www.w3.org/1999/xhtml'
			html_elementtree = ET.ElementTree(element=html)

			text = '<?xml version="1.0" encoding="UTF-8"?>\n' \
				+ '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n' \
				+ ET.tostring(html_elementtree, encoding="utf-8", pretty_print=True)
			epub.writestr(topsect_filename, text, zipfile.ZIP_DEFLATED)

			i += 1

		#---------------------------------------------
		# Zip each embedded images and add it to
		# the manifest
		#---------------------------------------------
		i = 1
		for image_filename, image_mimetype, image_compression in self.images:
			manifest.append(E.item({
				"id":"img-%d" % i,
				"href":image_filename,
				"media-type":image_mimetype,
				}))
			i += 1
			if image_mimetype == "image/svg+xml":
				data = self.read_svg(image_filename)
			else:
				data = self.odt.open(image_filename).read()
			epub.writestr(image_filename, data, image_compression)

		#---------------------------------------------
		# Zip content index and table of contents
		#---------------------------------------------
		epub.writestr("content.opf",
			ET.tostring(ET.ElementTree(element=index_tpl), encoding="utf-8", pretty_print=True),
			zipfile.ZIP_DEFLATED
			)
		epub.writestr("toc.ncx", self.epub_toc(epub_uuid), zipfile.ZIP_DEFLATED)

	def epub_css(self):
		# The base CSS stylesheet for ebook readers. Remember that
		# this is CSS 2.1, so no @media queries.
		css = textwrap.dedent("""\
			HTML, BODY, H1, H2, H3, H4, H4, P { margin: 0; padding: 0 }
			BODY { margin: 0.125in; font-size: 12pt }
			H1, H2, H3, H4, H4 { font-size: inherit }
			UL { margin: 0 }
			TABLE { border-collapse: collapse }
			TH, TD { vertical-align: top }
			HR.pagebreak { margin: 0.5in -0.5in 0.5in -0.5in }
			SPAN.space { white-space: pre-wrap }
			""")

		# Add the converted styles from the ODT file, again limited to CSS 2.1.
		css += "\n".join(self.styles.get_css(2.1))

		return css

	def epub_toc(self, epub_uuid):
		ncx = ET.Element(
			"{http://www.daisy.org/z3986/2005/ncx/}ncx",
			{	"version": "2005-1",
				},
			nsmap = {
				None:"http://www.daisy.org/z3986/2005/ncx/",
				},
			)

		ncx_head = E.head()
		ncx.append(ncx_head)
		ncx_head.append(E.meta({"name":"dtb:uid","content":epub_uuid}))
		ncx_head.append(E.meta({"name":"dtb:depth","content":"1"}))
		ncx_head.append(E.meta({"name":"dtb:totalPageCount","content":"0"}))
		ncx_head.append(E.meta({"name":"dtb:maxPageNumber","content":"0"}))

		ncx.append(E.docTitle(E.text(self.title)))

		ncx_navmap = E.navMap()
		ncx.append(ncx_navmap)

		i = 1
		for h_filename, h_id, h_text in self.h1s:
			print "  H1:", h_filename, h_id, h_text
			ncx_navmap.append(
				E.navPoint(
					E.navLabel(E.text(h_text)),
					E.content({"src":"%s#%s" % (h_filename, h_id)}),
					{	"id":"navpoint-%d" % i,
						"playOrder":"%d" % i
						},
					),
				)
			i += 1

		text = '<?xml version="1.0" encoding="UTF-8"?>\n' \
			+ '<!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd">\n' \
			+ ET.tostring(ET.ElementTree(element=ncx), encoding="utf-8", pretty_print=True)

		return text

	#============================================================================
	#
	#============================================================================

	# Is this element empty of text and children?
	def element_empty(self, el):
		return el.text is None and el.tail is None and len(list(el)) == 0
	
	# Extract text from an ODT element and its children. Throw away
	# any formatting.
	def element_extract_text(self, el):
		text = ""
		if el.text is not None:
			text += el.text
		for child_el in el:
			text += self.element_extract_text(child_el)
		if el.tail is not None:
			text += el.tail
		return text
						
	# Convert an href which may have pointed to the ODT file to point
	# to the converted version instead.
	def href_to_html(self, href):
		return re.sub(r'\.odt$', '.html', href, flags=re.IGNORECASE)

#============================================================================
# These classes take ODF stylesheets and convert them to CSS stylesheets.
#============================================================================
class CssStyle(object):
	def __init__(self, name):
		self.name = name			# name for ODF file
		self.template = None		# printf style template
		self.properties = {}		# what to put inside the curly brackets
		self.media = None			# media query condition
		self.used = False			# mentioned in document?
		self.subst = None			# is this the same as some other style?
		self.break_before = None	# "page" for page break before
	def hashable(self):
		return (self.template, str(self.properties))
	def set_parent(self, parent):
		self.properties.update(parent.properties)
		self.media = parent.media
		self.break_before = parent.break_before

class OdtStyle2Css(object):
	# Generic font names in ODF are different from those in CSS!
	font_family_map = {
		"roman":"serif",
		"swiss":"sans-serif",
		"modern":None,
		"script":"cursive",
		}

	def __init__(self, debug, keep_unused_styles, collapse_styles, simplify_table_borders, font_support_level):
		self.debug = debug
		self.keep_unused_styles = keep_unused_styles
		self.collapse_styles = collapse_styles
		self.simplify_table_borders = simplify_table_borders
		self.font_support_level = font_support_level

		self.dimensions_re = re.compile("(^[-0-9\.]+)((in)|(pt)|(mm)|(cm)|(px))$")
		self.fonts = {}
		self.styles_ordered = []		# it may be nice to preserve the original order
		self.styles_byselector = {}		# for inclusion of parent styles
		self.styles_byname = {}
		self.styles_byhashable = {}

	# When you find the <font-face-decls>, pass it to this function.
	def add_fonts(self, odt_font_face_decls):
		for font_face in odt_font_face_decls:
			name = font_face.attrib["name"]
			font_families = []
			if self.font_support_level >= 2 and "font-family" in font_face.attrib:
				value = font_face.attrib["font-family"]
				font_families.append(value)
			if "font-family-generic" in font_face.attrib:	
				value = font_face.attrib["font-family-generic"]
				value = self.font_family_map.get(value, None)
				if value is not None:
					font_families.append(value)
			if "font-pitch" in font_face.attrib:
				value = font_face.attrib["font-pitch"]
				if value == "fixed":
					font_families.append("monospace")
			self.fonts[name] = ",".join(font_families)

	# When you find <styles>, pass it to this function.
	def add_stylesheet(self, odt_stylesheet):
		if self.debug:
			print "===== Converting ODF Stylesheet ====="
		dependent = []
		# Make one pass.
		for style in list(odt_stylesheet):
			if not self.add_style(style):
				dependent.append(style)
		# Make a second pass to convert styles which had unresolved dependencies.
		for style in dependent:
			if not self.add_style(style):
				raise OdfInvalid("missing parent for style: %s %s" % (style.tag, style.attrib))
		if self.debug:
			print

	# Take an ODF style tag and its children and convert them to CSS
	def add_style(self, odt_style):
		if self.debug:
			print "  %s %s" % (odt_style.tag, odt_style.attrib)
		if odt_style.tag == "style":
			css_style = CssStyle(odt_style.attrib['name'])

			style_family = odt_style.attrib['family']
			if style_family == "text":
				css_style.template = "SPAN.%s"
			elif style_family == "paragraph":
				css_style.template = ".%s"	# P, H[12345], LI, or even TD
			elif style_family == "table":
				css_style.template = "TABLE.%s"
			elif style_family == "table-column":
				css_style.template = "COL.%s"
			elif style_family == "table-cell":
				if self.simplify_table_borders:
					css_style.template = "TABLE.%s TD"
				else:
					css_style.template = "TD.%s"
			elif style_family == "graphic":
				css_style.template = "IMG.%s"
			elif style_family == "section":
				css_style.template = "DIV.%s"
			else:
				if self.debug:
					print "    unimplemented style family: %s" % style_family
				return True

			# If this style has a parent, import its attributes.
			parent_style_name = odt_style.attrib.get("parent-style-name")
			if parent_style_name is not None:
				parent_style = self.styles_byselector.get((css_style.template,parent_style_name))
				if parent_style is None:
					if self.debug:
						print "    deferring loading"
					return False
				css_style.set_parent(parent_style)

			# Process the style's children
			for el in odt_style:
				if self.debug:
					print "    %s %s" % (el.tag, odt_style.attrib)
				if not el.tag.endswith("-properties"):
					if self.debug:
						print "      unimplemented style child: %s" % el.tag
					continue

				# Convert properties which are generally applicable to block items.
				for prop in (
						"margin", "margin-left", "margin-right", "margin-top", "margin-bottom",
						"padding", "padding-left", "padding-right", "padding-top", "padding-bottom",
						"border", "border-left", "border-right", "border-top", "border-bottom",
					):
					if prop in el.attrib:
						value = el.attrib[prop]
						if value != "100%":		# don't know what 100% is supposed to mean, but it is poison...
							css_style.properties[prop] = self.clean_dimensions(value)

				# Convert percentage line height to multiplication factor because percentage
				# line height is inherited differently in ODF and in CSS.
				if "line-height" in el.attrib:
					value = el.attrib["line-height"]
					m = re.match(r'^(\d+)%$', value)
					if m:
						value = "%.2f" % (int(m.group(1)) / 100.0)
					css_style.properties["line-height"] = value
					

				# Text in blocks or inline
				if el.tag == "text-properties":
					if self.font_support_level >= 1:
						font_name = el.attrib.get("font-name")
						if font_name is not None:
							font_family = self.fonts[font_name]
							if font_family != "":
								css_style.properties["font-family"] = font_family

					for prop in ("font-size", "font-style", "font-weight", "background-color"):
						if prop in el.attrib:
							css_style.properties[prop] = el.attrib[prop]

					# Drop black except on spans since we believe it is just noise.
					if "color" in el.attrib:
						color = el.attrib["color"]
						if color != "#000000" or style_family == "text":
							css_style.properties["color"] = color

					if "text-position" in el.attrib:
						m = re.match("^((super)|(sub)|(\d+%))( (\d+%))?$", el.attrib["text-position"])
						if not m:
							raise OdfNotImplemented("unrecognized text position: %s" % el.attrib["text-position"])
						else:
							vertical_align = m.group(1)
							font_scale = m.group(6)
							if font_scale is None:
								if vertical_align == "super" or vertical_align == "sub":
									font_scale = "60%"
							if vertical_align == "0%":
								print "  Warning: nested text-position in %s not converted correctly" % css_style.name
							else:
								css_style.properties["vertical-align"] = vertical_align
								if font_scale is not None:
									css_style.properties["font-size"] = font_scale

					if el.attrib.get("text-underline-style","none") != "none":
						css_style.properties["text-decoration"] = "underline"

					# FIXME: cancels underlining
					if el.attrib.get("text-line-through-style","none") != "none":
						css_style.properties["text-decoration"] = "line-through"

				# To text blocks
				elif el.tag == "paragraph-properties":
					for prop in ("text-align", "text-indent", "background-color"):
						if prop in el.attrib:
							css_style.properties[prop] = el.attrib[prop]
					if "break-before" in el.attrib:
						css_style.break_before = el.attrib["break-before"]
						# Webkit uses non-standard attribute
						if el.attrib["break-before"] == "column":
							css_style.properties["-webkit-column-break-before"] = "always"

				elif el.tag == "table-properties":
					if "width" in el.attrib:
						width = el.attrib["width"]
						if self.dimension2points(width) > (6.5 * 72.0):
							width = "100%"
						css_style.properties["width"] = width
					else:
						css_style.properties["width"] = "100%"

				elif el.tag == "table-column-properties":
					if "column-width" in el.attrib:
						css_style.properties["width"] = el.attrib['column-width']

				elif el.tag == "section-properties":
					for el2 in el:
						if el2.tag == "columns":
							for prop in ("column-count", "column-gap"):
								if prop in el2.attrib:
									css_style.media = "(min-width:8in)"
									css_style.properties[prop] = el2.attrib[prop]
									css_style.properties["-webkit-%s" % prop] = el2.attrib[prop]
									css_style.properties["-moz-%s" % prop] = el2.attrib[prop]

			# FIXME: read up on this. Does this attribute really indicate a new page?
			# NOTE: this will override the break-before in <paragraph-properties>
			if "master-page-name" in odt_style.attrib and odt_style.attrib["master-page-name"] != "":
				css_style.break_before = "page"

			# If we are simplifying table cell borders, keep only one border setting
			# picking one which is not "none".
			if style_family == "table-cell" and self.simplify_table_borders:
				for name, value in list(css_style.properties.items()):
					if name.startswith("border-"):
						del css_style.properties[name]
						if value != "none":
							css_style.properties["border"] = value
				css_style.name = css_style.name.split(".")[0]

			if self.debug:
				print "    -->%s" % (css_style.template % css_style.name), css_style.properties
			self.styles_ordered.append(css_style)
			self.styles_byselector[(css_style.template, css_style.name)] = css_style
			self.styles_byname[css_style.name] = css_style

			hashable = css_style.hashable()
			css_style.subst = self.styles_byhashable.get(hashable)
			if css_style.subst is None:
				self.styles_byhashable[hashable] = css_style

		return True

	# Take an ODT style-name and replace any characters which
	# are not allowed in a CSS class name.
	def stylename2classname(self, style_name):
		return style_name.replace('.','_')

	# The HTML generator calls this when it adds an element which uses a styles.
	# If the style exists, a note is made to include it in the CSS and the 
	# HTML class to use is returned. Otherwise, None is returned.
	def claim_style(self, style_name):
		if not style_name in self.styles_byname:
			if not style_name.startswith("M"):
				print "  Warning: style %s used but not defined" % style_name
			return None		# nix it
		css_style = self.styles_byname[style_name]
		if self.collapse_styles and css_style.subst is not None:
			css_style = css_style.subst
		if len(css_style.properties) > 0 or self.keep_unused_styles:
			css_style.used = True
			return self.stylename2classname(css_style.name)

	def get_break_before(self, style_name):
		if not style_name in self.styles_byname:	# because we do not yet convert all styles
			return None
		return self.styles_byname[style_name].break_before

	# Return the converted styles as an array of CSS lines.
	def get_css(self, css_version):
		css = []

		for css_style in self.styles_ordered:
			if self.keep_unused_styles or (len(css_style.properties) > 0 and css_style.used):
				style_text = "%s{%s}" % (
					(css_style.template % self.stylename2classname(css_style.name)),
					";".join(["%s:%s" % (name, value) for name, value in css_style.properties.items()])
					)
				if css_style.media is not None and css_version >= 3.0:
					style_text = "@media %s { %s }" % (
						css_style.media,
						style_text
						)
				css.append(style_text)

		return css

	# Parse the right-hand side of a CSS style setting, find the numeric
	# dimensions and enforce a minimum size. In the process, all units
	# get converted to points.
	def clean_dimensions(self, style_arg):
		words = []
		for word in style_arg.split(" "):
			if self.dimensions_re.match(word):
				points = self.dimension2points(word)
				if points >= 0.8:
					word = "%.2fpt" % points
				elif points < 0.0001:
					word = "0pt"
				else:
					word = "thin"
			words.append(word)
		return " ".join(words)
	
	# Convert a CSS-style dimension with units into points.
	# We use this when making comparisons.
	def dimension2points(self, dimension):
		m = self.dimensions_re.match(dimension)
		if m:
			if m.group(2) == "pt":
				return float(m.group(1))
			elif m.group(2) == "in":
				return float(m.group(1)) * 72.0
			elif m.group(2) == "mm":
				return float(m.group(1)) * 72.0 / 25.4
			elif m.group(2) == "cm":
				return float(m.group(1)) * 72.0 / 2.54
			elif m.group(2) == "px":
				return float(m.group(1)) * 0.72			# about 100 DPI
		raise OdfNotImplementedYet("dimension not understood: %s" % dimension)

#============================================================================
# Exceptions
#============================================================================

# We don't have this case covered
class OdfNotImplementedYet(Exception):
	pass

# We know abou this case and do not play to support it
class OdfNotSupported(Exception):
	pass

# The input file looks corrupt
class OdfInvalid(Exception):
	pass

#============================================================================
# Main
#============================================================================
if __name__ == "__main__":
	import codecs
	sys.stdout = codecs.getwriter('utf-8')(sys.stdout)
	sys.stderr = codecs.getwriter('utf-8')(sys.stderr)

	debug = 0
	output_format = "html"
	force = False
	while len(sys.argv) >= 2 and sys.argv[1].startswith("--"):
		if sys.argv[1] == "--debug":
			debug = 1
			force = True
		elif sys.argv[1] == "--force":
			force = True
		elif sys.argv[1] == "--epub":
			output_format = "epub"
		else:
			sys.stderr.write("Unrecognized option: %s\n" % sys.argv[1])
			sys.exit(1)
		sys.argv.pop(1)

	for filename in sys.argv[1:]:
		filename = filename.decode("utf-8")		# FIXME: why do we have to do this?
		print u"\"%s\"" % filename

		basename, ext = os.path.splitext(filename)
		if ext != ".odt":
			sys.stderr.write("Not an ODT file.\n")
			sys.exit(1)
		output_filename = "%s.%s" % (basename, output_format)

		filename_mtime = os.path.getmtime(filename)
		if force or not os.path.exists(output_filename) or os.path.getmtime(output_filename) < filename_mtime:
			print "  rebuilding..."
	
			if os.path.exists(output_filename):
				os.unlink(output_filename)

			gz_filename = "%s.gz" % output_filename
			if os.path.exists(gz_filename):
				os.unlink(gz_filename)

			# Perform the conversion
			try:
				Odt2Html(filename, output_filename, output_format, debug)
			except OdfNotImplementedYet as e:
				sys.stderr.write("ODF Feature not implemented: %s\n" % unicode(e))
				sys.exit(1)
			except OdfNotSupported as e:
				sys.stderr.write("Change unsupported formatting: %s\n" % unicode(e))
				sys.exit(1)
			except OdfInvalid as e:
				sys.stderr.write("ODT file is invalid: %s\n" % unicode(e))
				sys.exit(1)

			# Make the creation time of the HTML file one millisecond after the
			# creation time of the ODT file from which it was made.
			os.utime(output_filename, (filename_mtime + 0.01, filename_mtime + 0.01))
		else:
			print "    up-to-date"

