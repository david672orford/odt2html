#! /usr/bin/python
# encoding=utf-8
# odt2html
# Copyright 2014--2016, Trinity College Computing Center
# Written by David Chappell
# Last modified: 19 December 2016

#=============================================================================
# To the User
#=============================================================================
#
# This program converts Opendocument word-processing files such as those 
# produced by Openoffice into clean HTML files.
#
# == Usage ==
# 
# odt2html [--debug] [--force] [--epub] <filename.odt>...
#
#  --debug               print debug messages
#  --force               regenerate the output file even if the input file is
#                        not newer
#  --epub                break the output into one HTML file per section and
#                        wrap them in an EPUB file
#  --template=<filename>
#  --snobject            add tags to make article a social media object
#
# Each input ODT file is converted to a single HTML or EPUB file. The output
# file will have the same base name and will be placed in the same directory.
#
# == Preparing Documents for Conversion ==
#
# This program is intended to be part of a 'document preparation workflow'.
# It can produce the web version of an ODF of document which you have
# carefully prepared so that it will reflow properly and does not contain
# any formatting which cannot be represented using straigh-forward HTML
# and CSS.
#
# When you format a document you are giving instructions to the word processor
# which tell it how to lay the elements out on a page. A common poor practice
# is to nudge the elements into their proper positions by adding and removing
# spaces and carriage returns. Such formatting breaks if the page size is
# changed or if material is added or removed. In contrast good formatting
# expresses the writer's intent in terms the word processor can understand
# such as "keep these paragraphs together if at all possible" or "do not
# break the line at this space".
#
# Since web pages can be resized almost without limit, it goes without saying
# that you must use good formatting in your ODF files. What is not so obvious
# is that you must add additional formatting for the document to remain
# readable during extreme resizing such as when it is displayed on a mobile
# telephone.
#
# Some examples of formatting problems which you should correct:
#
# * This program needs to know your document's title. It will look first
#   in the metadata (go to File->Properties and look under the Description
#   tab). If the title there is blank, it will look for level 1 headings
#   and take the first one as the title. If there are no level 1 headings,
#   the program will stop.
#
# * Tabs for formatting tabular data are not supported in HTML. This
#   converter will insert a few spaces for each tab, but unless the tabs
#   are used for indenting the start of a line, things will not line up
#   as you wished. Replace tabbed tables with actual tables. You can turn
#   the borders off if you wish.
#
# * Extra spaces which may have been inserted to adjust line breaking will
#   probably not produce the result you intended when the ODF file is
#   converted to HTML. Even if it does, it will break when the window size is
#   adjusted. Instead insert an explicit line break (shift-enter in
#   Openoffice) or use non-breaking spaces to prevent a line break at an
#   undesireable place.
#
# * Likewise, extra carriage returns (empty paragraphs) inserted to move a
#   page break will cause problems. There are no pages in a web browser
#   window and so the the extra space will only make a mess. Instead in
#   Openoffice go into paragraph formatting and in the Text Flow tab put a
#   checkmark next to "Keep with next paragraph". This not only get rid of
#   the spurious vertical space, but it will fix the bad break permanently in
#   the print and PDF versions.
#
# * If you have indented single-line paragraphs using spaces or tabs, perhaps
#   to represent a verse from a poem, you should reformat them to use a left
#   margin. Otherwise when the lines are wrapped on a narrow display, they
#   may become difficult to read. You may want to use a hanging indentation.
#
# * Watch out for superscripts and subscripts. In Openoffice there are
#   ways to put regular text inside a span of superscript or subscript
#   text. HTML has no provision for this. Writing code to unnest the spans
#   would be tricky, so we just warn you about it and expect you to fix
#   it in the source document. Select the text in question, chose 
#   Format->Clear Direct Formatting, and then select the parts which should
#   be superscripts or subscripts and again format them as such.
#
# If you correct these problems you will get an HTML version which is
# reasonably close to the printed or PDF version. But unlike the PDF
# version it will be reflowed to suit the size of the viewer's window.
# This generally works so well that documents originally formatted for
# US Letter paper can be read conformatly on the screen of a smartphone.
#
# == Supported ODF Features ==
#
# * Headings
# * Paragraph indentation
# * Font changes including family, weight, slant, superscript, subscript
# * Text color (forground and background)
# * Tables with borders and padding
# * Unordered Lists
# * Hyperlinks
# * Raster images in JPEG, GIF, and PNG formats
# * SVG drawings
# * Multiple columns
#
# == No Plans to Support ==
#
# * Embedded openoffice drawings (use SVG instead)
# * Tabs (not supported in HTML)
# * Individual column widths in multi-column sections (not supported in HTML)
#
# == Inter-Document Hyperlinks ==
#
# If you create hyperlinks between documents in a set and then convert them
# all to HTML using this program, the hyperlinks will be converted to link
# the HTML versions.
#
# == Master Documents ==
#
# To convert a master document, first export it as an ODT file and convert that.
# Hyperlinks between the subdocuments of a master document will be converted
# to internal links within the final document.
#
# == Adjustements for the Web ==
#
# A few CSS tricks improve reading on small screens. For one, the margins
# are cut from 1/2" to 1/8" for narrow screens. Second, multi-column layout
# is disabled for narrow screens.
#
# == Hyperlinks to Audio and Video Player Files ==
#
# If the target attribute of a hyperlink is "player", then it will be played in
# a popup player.
#
# The audio player takes the form of a horizontal bar at the bottom of the
# screen which contains an HTML 5 <audio> element, a menu of download links,
# and a close button. If the URL of the audio file is specified without an
# extension, then Odt2html will check to be sure you have both .mp3 and .ogg
# versions of the file and will produce a <source> element for each.
#
# The video player also pops up at the bottom of the screen. The size of the
# video player is 640x480 unless the window is narrower in which case it will
# be 480x360 or 320x240. If the URL is specified without an extension, then
# Odt2html will check to be sure you have both .mp4 and .webm versions and
# will produce a <source> element for each.
#
# == Speaking Table Cells ==
#
# Table cells which contain foreign language phrases can be made to play audio
# files or segements of a single when they are clicked. This is intended for
# for language phrasebooks.
#
# To set a document up for speaking table cells, create a user defined variable
# in the document properties called "TD Sound" and a type of "Text". The value
# should actually be two values separated by a colon:
# * A two-letter language code. If a table cell starts with a run of text marked
#   as being in this language, it is considered to be an candidate for a speaking
#   table cell.
# * A file system path relative to the ODT file. It should point either to a
#   directory or to an Audacity labels file with an extension of .txt.
#   * directory: must contain audio files in both MP3 and OGG format with names
#     matching the text
#   * Audacity labels file: must contain labels that match the text in the same
#     order as in the ODT file
# If the text in a table cell (though of the correct language) does not match
# a file in the directory specified or does not match the next message in the
# Audacity labels file specified, it will be skipped and will not speak.
#

#=============================================================================
# Programmer's Notes
#=============================================================================
#
# == Opendocument ==
# * https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=office
# * http://docs.oasis-open.org/office/v1.2/OpenDocument-v1.2-part1.html
#
# == Python Elementtree ==
# * https://docs.python.org/2/library/xml.etree.elementtree.html
# * http://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree/
# * http://lxml.de/
# * http://lxml.de/lxmlhtml.html
#
# == Epub ==
# * http://www.manuel-strehl.de/dev/simple_epub_ebooks_with_python.en.html
# * https://code.google.com/p/python-epub-builder/
#
# == Social Networking ==
# * https://developers.google.com/+/web/snippet/
# * https://developers.google.com/structured-data/testing-tool/
#
# == TODO ==
# * Mixed ordered/unordered lists are not implemented. Should they be?
# * Implement document background color
# * Convert default paragraph style
# * Implement alignment of tables to right document margin
# * Implement more image placement possibilities
# * Reimplement style simplification:
#   * Simplify more to make the CSS smaller
#   * It would be nice if we no longer needed to provide options
#   * Paragraph styles which are functionally the same as their parents
#     should be eliminated
#   * Table cell borders should be simplified only if they are all the same.
# * Figure out what ODF bookmarks are and whether we should implement them
# * Drop page numbers from table of contents since they will be wrong even if
#   the HTML file is printed from a browser
# * Finish alphabetical index extraction
# * Table styles collide with paragraph styles. To demonstrate, try naming a
#   table "Heading".
# * Add support for HLS video
# * Playing of audio fragments may not work on some browsers if the file is
#   not encoded with a constant bitrate. Detect this automatically.
#

import zipfile
import sys
import os
import lxml.etree as ET
from lxml.builder import E
import lxml.html
import urllib
import re
import textwrap
import uuid
import fnmatch
import copy
import codecs

#============================================================================
# ODT to HTML Converter
#============================================================================
class Odt2HtmlOptions(object):
	debug = False						# --debug
	output_format = "html"
	template = None						# --template=
	snobject = False					# --snobject
	player_lib_dir = '../lib/odt2html'	# --player-lib-dir=

	# If False, then only one HTML file will be generated.
	# If True, then one HTML file will be generated for
	# each top-level <text:section>.
	split_by_sections = False

	# Use data: URLs for embedded images?
	use_data_urls = True

	# If the ODT file contains a table or contents, should we keep it?
	keep_toc = True

	# 0: weight and slant, 1: generic families, 2: specific families
	font_support_level = 1

	# Convert SVG files to PNG files?
	svg2png = False

	# Should we drop styles from the ODT file which are not
	# used in the text?
	# FIXME: does not work correctly
	drop_unused_styles = False

	# If two styles have the same right-hand-side, keep only
	# first one. This reduces file size, but you should not
	# do this if you intend to edit the resulting style sheet
	# later since styles which should represent different things
	# will have been combined just because they look the same.
	collapse_styles = False

	# Openoffice uses unnecessarily complicated table border styles.
	# Even though the borders of ajoining cells should collapse,
	# it takes great care to define a border for only one of the
	# cells.
	simplify_table_borders = True

	# Take tables which contain "Box" in their names and turn them into
	# wrappable containers of boxes.
	wrap_tables = True

class Odt2Html(object):
	def __init__(self, odt_filename, output_filename, opts=None):
		self.odt_filename = odt_filename
		self.opts = opts if opts else Odt2HtmlOptions()

		self.output_dirname = os.path.dirname(output_filename)		# directory of output file
		if self.output_dirname == "":
			self.output_dirname = "."

		self.td_sound = None										# speaking table cells

		self.depth = 0				# recursion level
		self.section_count = None	# current top-level section
		self.subdocs_by_href = {}	# sections which represent child documents
		self.title = None			# document title
		self.title_el = None
		self.h1s = []				# level 1 headings
		self.images = []			# images to include in .epub file
		self.player_loaded = False	# Does this document use an audio or video player?

		if self.opts.output_format == "html":
			self.load_and_convert()
			if self.td_sound:
				self.enable_td_sound()
			if self.opts.wrap_tables:
				self.wrap_tables()
			if self.opts.template:
				self.add_template()
			if self.opts.snobject:
				self.add_schema_article()
				self.add_opengraph()
			self.embed_stylesheet()
			self.save_html(output_filename)
		elif self.opts.output_format == "epub":
			self.opts.use_data_urls = False
			self.opts.keep_toc = False
			self.opts.split_by_sections = True
			self.opts.use_html5 = False
			#self.opts.svg2png = True
			self.load_and_convert()
			self.save_epub(output_filename)
		else:
			raise Exception

	#============================================================================
	# Load the style and content XML files into memory and create most of the
	# output HTML document in memory.
	#============================================================================
	def load_and_convert(self, data_urls=True):
		# Open the ODT file and show what is inside it
		self.odt = zipfile.ZipFile(self.odt_filename)
		if self.opts.debug:
			print "===== ODT File Contents ====="
			for resource_filename in self.odt.namelist():
				print "  %s" % resource_filename
			print

		# Uncompress and parse the XML streams which we need.
		styles_xml = self.load_xml("styles.xml")
		content_xml = self.load_xml("content.xml")
		meta_xml = self.load_xml("meta.xml")

		# Parse the styles from styles.xml and content.xml
		self.styles = OdtStyle2Css(self.opts)
		for font_face_decls in (
			styles_xml.xpath("/document-styles/font-face-decls")[0],
			content_xml.xpath("/document-content/font-face-decls")[0],
			):
			self.styles.add_fonts(font_face_decls)
		for stylesheet in (
			styles_xml.xpath("/document-styles/styles")[0],				# from stylesheet UI
			#styles_xml.xpath("/document-styles/automatic-styles")[0],	# used in master styles
			content_xml.xpath("/document-content/automatic-styles")[0]	# from element format UI
			):
			self.styles.add_stylesheet(stylesheet)

		# Create HTML objects into which we can start
		# to insert objects to represent the output document
		self.html_head = E.head()
		self.html_head.append(E.meta({"http-equiv":"content-type","content":"text/html; charset=utf-8"}))
		self.html_body = E.body()

		# Search for the title of the document
		titles = meta_xml.xpath("/document-meta/meta/title")
		if len(titles) > 0 and titles[0].text is not None:
			self.title = titles[0].text
		else:
			headings = content_xml.xpath("/document-content/body/text//h")
			if len(headings) > 0:
				self.title = self.element_extract_text(headings[0])
		if self.title is None:
			raise OdfNotSupported("No document title")
		self.title_el = E.title(self.title)
		self.html_head.append(self.title_el)

		# Search for the description of the document
		subjects = meta_xml.xpath("/document-meta/meta/subject")
		if len(subjects) > 0 and subjects[0].text is not None:
			self.html_head.append(E.meta({'name':'description','content':subjects[0].text}))

		# Search the keywords of the document
		keywords = meta_xml.xpath("/document-meta/meta/keyword")
		if len(keywords) > 0:
			self.html_head.append(E.meta({'name':'keywords','content':",".join(map(lambda keyword: keyword.text, keywords))}))

		# Look for odt2html configuration items in the document user data.
		for variable in meta_xml.xpath("/document-meta/meta/user-defined"):
			name = variable.attrib.get("name")
			if name == "TD Sound":
				self.td_sound = variable.text
			else:
				pass

		# Get a pointer to the ODT document body.
		odt_body = content_xml.xpath("/document-content/body/text")[0]

		# Pass 1
		self.section_count = 0
		for odt_el in odt_body:
			self.scan_element(odt_el)

		# Pass 2: convert the document and append it to the HTML body
		self.section_count = 0
		for odt_el in odt_body:
			self.convert_element(odt_el, self.html_body, None)

		# Convert the footer and add it to the body
		odt_footer = styles_xml.xpath("/document-styles/master-styles/master-page[@name='Standard']/footer/p")
		if len(odt_footer) >= 1:
			html_footer = E.div({"class":"footer"})
			self.convert_element(odt_footer[0], html_footer, None)
			self.html_body.append(E.footer(html_footer))

		# Do post-processing on table cells.
		for td in self.html_body.xpath(".//td"):

			# Table cells should not have text directly inside them (yet).
			assert td.text is None, "unexpected text: \"%s\"" % td.text

			# Nor should they have trailing text
			assert td.tail is None, "unexpected tail: \"%s\"" % td.tail

 			# If this <td> contains a single paragraph, subsume it.
			if len(td) == 1 and td[0].tag == "p" \
				and not self.styles.test(td[0].attrib.get('class'), 'margin*') \
				and not self.styles.test(td[0].attrib.get('class'), 'border'):
				p = td[0]
				classes = []
				if "class" in td.attrib:
					classes.append(td.attrib["class"])
				if "class" in p.attrib:
					classes.append(p.attrib["class"])
				if len(classes) > 0:
					td.attrib["class"] = " ".join(classes)
				if "lang" in p.attrib:
					td.attrib["lang"] = p.attrib["lang"]
				td.text = p.text
				for child in p:
					td.append(child)
				td.remove(p)
				if td.text is None or len(td.text) < 25:		# unwrap short <td>'s
					td.tail = ""

	#============================================================================
	# Load one of the XML files embedded in the ODT file
	#============================================================================
	def load_xml(self, filename):
		if self.opts.debug:	
			print "===== %s =====" % filename

		tree = ET.parse(self.odt.open(filename))

		# Strip namespace URIs from tag and attribute names
		for el in tree.iter():
			if isinstance(el, ET._Comment):
				continue
			el.tag = el.tag.split("}")[1]
			attrib = {}
			for name, value in el.attrib.items():
				short_name = name.split("}")[1]
				del el.attrib[name]
				el.attrib[short_name] = value

		if self.opts.debug:
			#print ET.tostring(tree, pretty_print=True, encoding="utf-8").decode("utf-8")
			print ET.tostring(tree, pretty_print=True, encoding="unicode")

		return tree

	#============================================================================
	# Pass 1
	#============================================================================
	def scan_element(self, odt_el):
		# Collect the source file names of the subdocuments of a master document.
		# We need this information in order to resolve links between subdocuments.
		if odt_el.tag == "section":
			section_id = self.get_section_id(odt_el)
			subdoc_href = self.get_section_source_href(odt_el)
			if subdoc_href is not None:
				self.subdocs_by_href[subdoc_href] = section_id

	def get_section_id(self, odt_el):
		self.section_count += 1
		if 'name' in odt_el.attrib:
			return odt_el.attrib['name'].replace(" ","_")
		else:
			return "topsect%d" % self.section_count

	# If this section encloses a subdocument of a master document, return an
	# href to the subdocument with the extension changed to ".html".
	def get_section_source_href(self, odt_el):
		if odt_el.attrib.get("protected","false") != "true":
			return None
		section_sources = odt_el.xpath("./section-source")
		if len(section_sources) == 0:
			return None
		if len(section_sources) != 1:
			raise OdfInvalid("%d <section-source> elements" % len(section_sources))
		href = section_sources[0].attrib['href']
		return self.href_to_html(href)

	#============================================================================
	# Pass 2
	#============================================================================

	# This function converts an ODT element to HTML and adds it to the
	# parent HTML element specified. It then calls itself on each child
	# of the ODT element with the newly created HTML element as the 
	# target parent.
	def convert_element(self, odt_el, html_parent_el, list_style_name):
		convert_children = True

		style_name = odt_el.attrib.get('style-name')

		if odt_el.tag == "sequence-decls":		# mystery
			html_el = None
		elif odt_el.tag == "section":
			if self.opts.debug:
				print "  Section:", odt_el.attrib.get("name")
			html_el = E.div()
			if self.depth == 0:					# if at master document level
				section_id = self.get_section_id(odt_el)
				subdoc_href = self.get_section_source_href(odt_el)
				if subdoc_href:					# if this is a child of a master document,
					if self.section_count != self.subdocs_by_href[subdoc_href] != subdoc_id:
						raise OdfInvalid("Master document inconsistency")
				html_el.attrib["id"] = section_id
			else:
				html_el.attrib["id"] = odt_el.attrib['name'].replace(" ","_")
		elif odt_el.tag == "section-source":	# handled during pass 1
			html_el = None
		elif odt_el.tag == "h":
			if self.opts.debug:
				print "  Heading:", self.element_extract_text(odt_el), style_name
			level = int(odt_el.attrib['outline-level'])
			html_el = E("h%d" % level)
			if level == 1:	# level 1 headings have ID's

				if style_name and style_name.startswith("P"):
					print "  Warning: level 1 heading with paragraph style: %s" % style_name

				bookmarks = odt_el.xpath("./bookmark-start")
				if len(bookmarks) > 0:
					h_id = bookmarks[0].attrib["name"]
				else:
					h_id = "subh%d" % (len(self.h1s) + 1)
				h_filename = "content%d.html" % self.section_count
				h_text = self.element_extract_text(odt_el)
				html_el.attrib['id'] = h_id
				self.h1s.append((h_filename, h_id, h_text))
		elif odt_el.tag == "bookmark":
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "bookmark-start":
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "bookmark-end":
			html_el = E.span({"dropme":odt_el.tag})

		elif odt_el.tag == "p":					# paragraph
			# If this paragraph is the first one inside an <LI> tag, put everything
			# inside the <LI> instead since otherwise if the paragraph is indented
			# it will move away from the bullet.
			# FIXME: Does this have something to do with the style rule:
			#        LI, P { position: relative }
			if html_parent_el.tag == "li" and self.element_empty(html_parent_el):
				html_el = html_parent_el
			else:
				html_el = E.p()
		elif odt_el.tag == "span":				# text format
			html_el = E.span()
			html_el.tail = ""					# <-- prevents newline with pretty_print=True
		elif odt_el.tag == "a":
			html_el = self.convert_hyperlink(odt_el)
		elif odt_el.tag == "line-break":
			html_el = E.br()
		elif odt_el.tag == "soft-page-break":	# FIXME: read up on this
			html_el = ET.Comment("soft-page-break")
		elif odt_el.tag == "tab":
			if len(odt_el) != 0:
				raise OdfInvalid("<tab> should not have children")
			html_el = E.span({"class":"tab"})
			html_el.text = 8 * u" "				# eight non-breaking spaces
		elif odt_el.tag == "s":					# spaces
			if len(odt_el) != 0:
				raise OdfInvalid("<s> should not have children")
			count = int(odt_el.attrib.get("c","1"))
			if count == 1:
				html_el = E.span({"dropme":"s"})
				html_el.text = " "
			else:
				html_el = E.span({"class":"space"})
				count = int(count * 1.15)		# 1.15 is fudge
				html_el.text = count * " "
		elif odt_el.tag == "frame":
			html_el = self.convert_frame(odt_el)
			if html_el.tag == "img":			# if simplified to <img>,
				convert_children = False
		elif odt_el.tag == "text-box":
			html_el = E.div()
		elif odt_el.tag == "page-number":		# FIXME: what about the content (which is an actual page number)?
			html_el = ET.Comment("page-number")

		elif odt_el.tag == "table":
			html_el = E.table()
		elif odt_el.tag == "table-column":
			html_el = E.col()
		elif odt_el.tag == "table-header-rows":
			html_el = E.thead()
		elif odt_el.tag == "table-row":
			html_el = E.tr()
		elif odt_el.tag == "table-cell":
			html_el = E.td()
			if "number-rows-spanned" in odt_el.attrib:
				html_el.attrib["rowspan"] = odt_el.attrib["number-rows-spanned"]
			if "number-columns-spanned" in odt_el.attrib:
				html_el.attrib["colspan"] = odt_el.attrib["number-columns-spanned"]
			if not self.styles.style_still_exists(style_name):	# if simplified away,
				style_name = None
		elif odt_el.tag == "covered-table-cell":
			html_el = None						# don't convert

		elif odt_el.tag == "list":
			if style_name:
				list_style_name = style_name
			if self.styles.styles_byname[list_style_name].tag == "OL":
				html_el = E.ol()
			else:
				html_el = E.ul()
		elif odt_el.tag == "list-header":
			raise OdfNotImplementedYet("list-header")
		elif odt_el.tag == "list-item":
			html_el = E.li()

		elif odt_el.tag == "table-of-content":
			if self.opts.keep_toc:
				html_el = E.div({"id":"toc"})
			else:
				html_el = None					# don't convert
		elif odt_el.tag == "table-of-content-source":
			html_el = None

		elif odt_el.tag == "alphabetical-index":
			html_el = E.div({"id":"index"})
		elif odt_el.tag == "alphabetical-index-source":
			html_el = None
		elif odt_el.tag == "alphabetical-index-mark":
			print "  Index entry:", odt_el.attrib['string-value'], odt_el.attrib.get('key1')
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "alphabetical-index-mark-start":
			print "  Index entry:", odt_el.attrib['id'], odt_el.tail
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "alphabetical-index-mark-end":
			html_el = E.span({"dropme":odt_el.tag})

		elif odt_el.tag == "index-body":
			html_el = E.div()
		elif odt_el.tag == "index-title":
			html_el = E.div()

		elif odt_el.tag == "user-defined":
			html_el = E.span({"class":"user-defined"})		# class is not used
		elif odt_el.tag == "variable-decls":
			html_el = None	# drop children too
		elif odt_el.tag == "variable-set":
			html_el = E.span({"dropme":odt_el.tag})
		elif odt_el.tag == "annotation":		# user note
			html_el = None

		# Forms not really implemented. All we do is draw a box for each control.
		elif odt_el.tag == "forms":
			html_el = None
		elif odt_el.tag == "control":
			html_el = E.span(
				{'style':'border: thin solid black;display:inline-block;width:100%%;max-width:%s;height:%s' % (
					odt_el.attrib['width'],
					odt_el.attrib['height']
					)}
				)

		# Unimplemented ODF tag
		else:
			#print "  Warning: unimplemented tag: %s" % odt_el.tag
			#html_el = E.span()
			raise OdfNotImplementedYet("unimplemented tag: %s" % odt_el.tag)

		if html_el is not None:
			if odt_el.text is not None:
				html_el.text = odt_el.text
			if odt_el.tail is not None:
				html_el.tail = odt_el.tail

			if style_name is not None:
				classname, language = self.styles.claim_style(style_name)
				if classname is not None:
					html_el.attrib['class'] = classname
				if language is not None:
					html_el.attrib['lang'] = language
				if self.styles.get_break_before(style_name) == "page":
					# This element should appear at the top of a new page.
					if len(self.html_body) > 0 or len(html_parent_el) > 0:		# if not at top of first page,
						if len(html_parent_el):									# if parent already has content
							html_parent_el.append(E.hr({"class":"pagebreak"}))
						else:													# otherwise, try to get it above parent
							self.html_body.append(E.hr({"class":"pagebreak"}))

			if convert_children:
				# Call this function recursively to convert the children.
				for child in odt_el:
					self.depth += 1
					self.convert_element(child, html_el, list_style_name)
					self.depth -= 1

				# Now run through the children collapsing the unnecessary spans
				# which Google Docs creates for no appearent reason.
				prev_child = None
				for child in html_el:
					#print child, child.text, child.tail, child.attrib

					if prev_child is not None \
							and child.tag == "span" and prev_child.tag == "span" \
							and child.attrib == prev_child.attrib \
							and prev_child.text is not None \
							and (prev_child.tail is None or prev_child.tail == "") \
							and len(prev_child) == 0 and len(child) == 0:
						#print "collapsed"
						if child.text is not None:
							prev_child.text += child.text
						if child.tail is not None:
							prev_child.tail = child.tail
						html_el.remove(child)

					else:
						prev_child = child

				# Look for spans containing only a stress mark. Since the stress mark is
				# a combining character, putting it alone in a span does not make any
				# sense. It also will not be rendered correctly on iPad browsers.
				for child in html_el:
					if child.tag == "span" and child.text == u"\u0301":
						#raise OdtBadFormatting("Spurious stress mark span")
						print "  Warning: spurious stress mark span"

			# If a <P> tag is completely empty, put a <BR> tag into it because
			# in HTML 4 empty <P> tags are supposed to be ignored.
			if odt_el.tag == "p" and self.element_empty(html_el):
				#html_el = E.br()
				html_el.append(E.br())

			# If this is a table, create a <tbody> and move the non-header
			# rows into it. We have to do this to pass XHTML 1.1 validation.
			if html_el.tag == "table":
				tbody = E.tbody()
				for child in list(html_el):
					if child.tag == "tr":
						html_el.remove(child)
						tbody.append(child)
				html_el.append(tbody)
				html_el = E.div(html_el, {'class':'restrain'})

			# There are some empty ODF tags which we want to ignore, but we 
			# cannot ignore them completely because they can come inside runs
			# of text and we do not want to lose their tail text. Here we
			# merge their text and tail text into either the parent element or the 
			# previous sibling element and then drop them.
			if "dropme" in html_el.attrib:
				if len(html_el) > 0:
					raise OdfInvalid("<%s> tag not empty" % html_el.attrib["dropme"])
				text = ""
				if html_el.text is not None:
					text += html_el.text
				if html_el.tail is not None:
					text += html_el.tail
				if text != "":
					if len(html_parent_el) == 0:
						if html_parent_el.text is None:
							html_parent_el.text = ""
						html_parent_el.text += text
					else:
						prev_el = html_parent_el[-1]
						if prev_el.tail is None:
							prev_el.tail = ""
						prev_el.tail += text

			# If we haven't dropped this tag in the previous code block and we
			# have not subsuming it into its parent, add it to its parent
			# append it to its parent.
			elif html_el != html_parent_el:
				html_parent_el.append(html_el)
				# Table columns and cells can be repeated
				for i in range(int(odt_el.attrib.get('number-columns-repeated', 1)) - 1):
					html_parent_el.append(copy.deepcopy(html_el))

	def convert_hyperlink(self, odt_el):
		assert odt_el.tag == 'a'
		href = odt_el.attrib["href"]
		target = odt_el.attrib.get("target-frame-name")
		title = odt_el.attrib.get("name","")

		# We provide a special target called "player" which opens a media file
		# in a popup player. This is not part of the ODF specification, but is
		# not really a hack either since the purpose of "target" is to specify
		# the place where the media should be displayed.
		if target == "player":
			filename = urllib.unquote(odt_el.attrib["href"])
			webvtt_url = None
			player_id = None

			if filename.startswith("../"):		# on same server
				m = re.match(r"^\.\./(.+)(\.[^\./]+)$", filename)
				if not m:
					raise OdtBadPlayer(filename)
				filename = m.group(1)
				extension = m.group(2)

				# Based on the extension, figure out what other extensions should
				# be present and whether this is an audio or a video program.
				if extension == ".ogg" or extension == ".mp3":
					extensions = ("ogg", "mp3")
					player = "play_audio"
				elif extension == ".webm" or extension == ".mp4":
					extensions = ("webm", "mp4")
					player = "play_video"
				else:
					raise OdfBadPlayer("extension not supported: %s.%s" % (filename, extension))

				# Make sure the file is present with all of the required extensions.
				for extension in extensions:
					test_filename = ("%s/%s.%s" % (self.output_dirname, filename, extension))
					if not os.path.exists(self.encode_filename(test_filename)):
						raise OdfBadPlayer("Missing %s file: \"%s\"" % (extension, test_filename))

				# The first extension listed is the one we will feed to the player.
				# It knows about the others.
				url = urllib.quote(("%s.%s" % (filename, extensions[0])).encode("utf-8"))

				filename = re.sub(r'\s+\d+x\d+$', '', filename)		# remove " 640x480"
				test_filename = ("%s/%s.vtt" % (self.output_dirname, filename))
				if self.opts.debug:
					print "  Webvtt:", test_filename
				if os.path.exists(self.encode_filename(test_filename)):
					webvtt_url = urllib.quote(("%s.vtt" % filename).encode("utf-8"))

				frames = odt_el.xpath('./frame')
				assert len(frames) == 1
				name = frames[0].attrib['name']
				player_id = name[4:] if name.startswith('Play') else None

			elif filename.startswith("http://") and filename.endswith(".mp4"):
				player = "play_video"
				url = filename

			elif filename.startswith("http://") and filename.endswith(".mp3"):
				player = "play_audio"
				url = filename

			else:
				raise OdfNotSupported("Unsupported URL: %s" % filename)

			self.require_player()

			html_el = E.span({
				'class':'play_link',
				'onclick':'%s("%s","%s",%s,%s)' % (player, url, title, self.js_arg(webvtt_url), self.js_arg(player_id))
				})

		# Other target
		else:
			#print "  href: %s" % href
			if href.startswith("http:"):		# Internet
				pass
			elif href.startswith("https:"):		# Internet
				pass
			elif href.startswith("ftp:"):		# Internet
				pass
			elif href.startswith("../"):		# relative to zip root (but outside)
				href_html = self.href_to_html(href)		# convert extension
				if href_html in self.subdocs_by_href:	# in same master document?
					if self.opts.split_by_sections:
						href = "content%s.html" % self.subdocs_by_href[href_html]
					else:
						href = "#%s" % self.subdocs_by_href[href_html]
				else:
					# Make sure the file named (likely an ODT or HTML file) exists
					href = href[3:]
					fs_path = os.path.join(os.path.dirname(self.odt_filename), urllib.url2pathname(href))
					# FIXME: file system encoding might not be UTF-8
					if os.path.exists(fs_path.encode("utf-8")):
						#print "  href: %s" % fs_path
						pass
					else:
						print "  Warning: broken link: %s" % fs_path
					# Whether it exists or not, point to the HTML version
					href = href_html[3:]
			elif href.startswith("#"):			# internal link
				pass
			else:
				raise OdfNotImplementedYet("href of unimplemented type: %s" % href)
			html_el = E.a({"href":href})
			if target is not None:
				html_el.attrib['target'] = target

		if title is not None:
			html_el.attrib['title'] = title
		html_el.tail = ""
		return html_el

	def encode_filename(self, filename):
		# FIXME: file system encoding might not be UTF-8
		return filename.encode("utf-8")

	def js_arg(self, arg):
		if arg is None:
			return "null"
		else:
			return '"%s"' % arg

	# If a frame contains an image, convert it to an <img>, otherwise
	# convert it to a <div>.
	#
	# FIXME: for some reason frames come wrapped in paragraphs. We should
	# hoise them out of the paragraphs.
	def convert_frame(self, odt_frame):
		odt_images = odt_frame.xpath("./image")
		if len(odt_images) > 0:
			href = odt_images[0].attrib['href']
			html_el = E.img({"src": self.add_image(href)})
			titles = odt_frame.xpath("./title")
			if len(titles) > 0:
				html_el.attrib["alt"] = titles[0].text
			else:
				print "  Warning: image without alt text"
			if self.opts.snobject and odt_frame.attrib.get("name") == "sm_image":
				pass		# FIXME
		else:
			html_el = E.div()

		style = []
		for attrib in ("width", "height", "min-width", "min-height", "max-width", "max-height"):
			if attrib in odt_frame.attrib:
				style.append("%s:%s" % (attrib, odt_frame.attrib[attrib]))

		# FIXME: figure out how 'from-left' is really supposed to work. Disabled until we can fix this.
		#if odt_frame.attrib['anchor-type'] == 'paragraph':
		#	if 'x' in odt_frame.attrib:
		#		style.append('margin-left:%s' % odt_frame.attrib['x'])
		#	if 'y' in odt_frame.attrib:
		#		style.append('margin-top:%s' % odt_frame.attrib['y'])

		html_el.attrib['style'] = ";".join(style)
		return html_el

	# Request the addition of an image to the output document.
	# Returns either a data: URL or the path which the image
	# will occupy in the output file tree.
	def add_image(self, filename):
		image = Odt2HtmlImage(self.odt, filename, self.opts.svg2png)

		if self.opts.use_data_urls:
			# http://www.websiteoptimization.com/speed/tweak/inline-images/
			image_data = image.get_data(pretty_print=False)
			#print "  Data URL for %s: %d bytes" % (image.filename, len(image_data))
			return "data:%s;base64,%s" % (image.mimetype, image_data.encode("base64"))
		else:
			self.images.append(image)
			return image.filename

	# Load the audio and video players
	def require_player(self):
		# If this is the first play button in this document, add the resources.
		if not self.player_loaded:
			self.html_head.append(E.link({
				'rel':'stylesheet',
				'type':'text/css',
				'href':'%s/player-v8.css' % self.opts.player_lib_dir,
				}))
			self.html_head.append(E.script({
				'type':'text/javascript',
				'src':'%s/player-v7.js' % self.opts.player_lib_dir,
				}))
			self.player_loaded = True

	#============================================================================
	# Post processing of generated HTML
	#============================================================================

	# Embed the CSS stylesheets in the document <head>
	def embed_stylesheet(self):

		# Style is responsive
		self.html_head.append(E.meta({"name":"viewport","content":"width=device-width,initial-scale=1"}))

		# The base stylesheet for web browers
		self.add_css("""\
			HTML,BODY,H1,H2,H3,H4,H4,P,OL,UL,LI { margin:0; padding:0 }
			BODY { font-size:12pt }
			H1,H2,H3,H4,H4 { font-size:inherit }
			UL,OL { list-style-position:outside }
			LI,P { position:relative }
			DIV.restrain { max-width:100% }
			TABLE { border-collapse:collapse }
			TH,TD { }
			DIV.wrap { display:flex; flex-flow:row wrap }
			DIV.wrap DIV { display: inline-block; margin: 1px; display: flex; flex-direction: column }
			HR.pagebreak { margin:0.5in }
			SPAN.space { white-space:pre-wrap }
			DIV.footer { margin-top:0.2in; font-size:8pt; white-space:nowrap; max-width:100%; overflow:hidden }
			@media print { @page { margin:0.5in } }
			@media screen {		/* push down footer */
				HTML { height:100% }
				BODY { position:relative; box-sizing:border-box; min-height:100%; margin:0 3%; padding:0.3in 0 0.4in }
				DIV.footer { position:absolute; left:0; bottom:0.1in; margin:0; }
				}
			""")

		# Add the converted styles from the ODT document.
		self.add_css("\n".join(self.styles.get_css(3.0)))

	# Load a template HTML file and copy some things from it
	# to the output document.
	def add_template(self):
		template = lxml.html.parse(open(self.opts.template))

		# Copy <link>, <style>, and <script> elements from the <head>
		for el in template.xpath("//head")[0]:
			if el.tag in ("link", "style", "script"):
				self.html_head.append(el)

		# If the template has a title, prepend it to the document's title
		template_title = template.xpath("//head/title")
		if template_title:
			template_title = template_title[0].text
			if template_title:
				self.title_el.text = "%s: %s" % (template_title, self.title)

		# Copy <nav> elements from the template's body while replacing
		# the string "TITLE" with the document's title.
		basename = os.path.splitext(os.path.basename(self.odt_filename))[0]
		i = 0
		for template_nav in template.xpath("//body/nav"):
			for el in ((template_nav,) + tuple(template_nav.xpath(".//*"))):
				if el.text:
					el.text = el.text.replace("{{TITLE}}", self.title)
				if el.tail:
					el.tail = el.tail.replace("{{TITLE}}", self.title)
				if "href" in el.attrib:
					if el.attrib['href'] == "{{ODT}}":
						el.attrib['href'] = "%s.odt" % basename
					elif el.attrib['href'] == "{{PDF}}":
						el.attrib['href'] = "%s.pdf" % basename
			self.html_body.insert(i, template_nav)
			i += 1

	# Add schema.org/Article
	# https://developers.google.com/+/web/snippet/#documentation
	def add_schema_article(self):
		self.html_head.attrib['itemscope'] = ''
		self.html_head.attrib['itemtype'] = 'http://schema.org/Article'

		#self.html_head.append(E.meta({'itemprop':'headline','content':self.title}))
		self.title_el.attrib['itemprop'] = 'headline'

		descriptions = self.html_head.xpath(".//meta[@name='description']")
		if len(descriptions) >= 1:
			descriptions[0].attrib['itemprop'] = 'description'

	# Add Open Graph
	# http://ogp.me/
	def add_opengraph(self):
		self.html_head.attrib['prefix'] = 'og: http://ogp.me/ns#'

		self.html_head.append(E.meta({'property':'og:title','content':self.title}))

		descriptions = self.html_head.xpath(".//meta[@name='description']")
		if len(descriptions) >= 1:
			descriptions[0].attrib['property'] = 'og:description'

	# Go through the generated HTML, identify speaking table cells, load the
	# JavaScript and CSS resources required, and hook the cells up.
	def enable_td_sound(self):
		if self.opts.debug:
			print "Enabling TD sound..."
		td_sound_lang, td_sound_path = self.td_sound.split(":")
		m = re.match(r'^(.+)\.txt$', td_sound_path)
		if m:
			td_sound_finder = LabelSoundFinder(self.output_dirname, m.group(1))
		else:
			td_sound_finder = DirSoundFinder(self.output_dirname, td_sound_path)

		for td in self.html_body.xpath(".//td"):
			for el in ((td,) + tuple(td)):		# Iterate through the <TD> and its immediate children
				if el.attrib.get("lang") == td_sound_lang:
					text = self.element_extract_text(el).strip()
					if text:
						url = td_sound_finder.find(text)
						if url:
							self.require_player()
							td.attrib['onclick'] = 'bgplay("%s")' % url
							td.attrib['class'] = td.attrib.get('class','') + " play"
						if self.opts.debug:
							print u"  %s TD: %s %s" % (td_sound_lang, text, "OK" if url else "Missing")
						break

	# If a table contains the string "Box", convert it to a box of boxes.
	# To do this we:
	# * Convert <table> to <div class="wrap">
	# * Drop <col>, <tr>, and <tbody>
	# * Convert the <td> elements to <div> elements and reinsert them
	# FIXME: The way we fix up the styles is a horrible hack which breaks
	# encapsulation. This was done deliberately because the style system
	# is a mess in need of a rewrite, so we did not want to implement this
	# correct without breaking something.
	def wrap_tables(self):
		if self.opts.debug:
			print "Fixing up wrappable tables..."
		for table in self.html_body.xpath(".//table"):
			if "Wrap" in table.attrib['class']:
				if self.opts.debug:
					print "  %s: wrapping" % table.attrib['class']
				table.tag = "div"
				table.attrib['class'] += " wrap"
				table_css_style = self.styles._by_css_class(table.attrib['class'])
				table_css_style.template = "DIV.%s"
				if 'max-width' in table_css_style.properties:
					del table_css_style.properties['max-width']
	 			boxes = []
				for el in table:
					if el.tag == "tbody":
						for tr in el:
							el.remove(tr)
							css_style = self.styles._by_css_class(tr.attrib.get('class'))
							if css_style is not None:
								css_style.template = "DIV.%s > DIV"
								css_style.name = table_css_style.name
							for td in tr:
								tr.remove(td)
								td.tag = "div"
								# If there is a style rule for this table cell and it is not yet converted,
								css_style = self.styles._by_css_class(td.attrib.get('class',None))
								if css_style is not None and not 'justify-content' in css_style.properties:
									css_style.template = "DIV.%s"
									vertical_align = css_style.properties.pop('vertical-align',None)
									css_style.properties['justify-content'] = {'top':'flex-start','middle':'center','bottom':'flex-end'}.get(vertical_align,'center')
								boxes.append(td)
					elif el.tag == "col":
						css_style = self.styles._by_css_class(el.attrib.get('class'))
						css_style.template = "DIV.%s > DIV"
						css_style.name = table_css_style.name
					table.remove(el)
				for box in boxes:
					table.append(box)
			elif self.opts.debug:
				print "  %s: no wrapping" % table.attrib['class']

	#============================================================================
	# Take the HTML BODY object in RAM, wrap it in an HTML element,
	# added a HEAD, and write it out to disk.
	#============================================================================
	def save_html(self, html_filename):
		# Write the HTML tree to a file
		outfh = open(html_filename, "w")
		outfh.write("<!DOCTYPE HTML>\n")
		html_elementtree = ET.ElementTree(element=E.html(self.html_head, self.html_body))
		html_elementtree.write(outfh, encoding="utf-8", pretty_print=True, method="html")

	#============================================================================
	# Create an EPUB file. An EPUB file is a zip file containing:
	# * The document as one or more XHTML files
	# * Images
	# * An XML table of contents
	# * A few other metadata files
	#============================================================================
	def save_epub(self, epub_filename):
		epub = zipfile.ZipFile(epub_filename, 'w')
		epub_uuid = uuid.uuid4().urn

		# MIME type must be first in file and uncompressed
		epub.writestr("mimetype", "application/epub+zip", zipfile.ZIP_STORED)

		# Boilerplate
		epub.writestr("META-INF/container.xml", textwrap.dedent("""\
			<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
				<rootfiles>
					<rootfile full-path="content.opf" media-type="application/oebps-package+xml"/>
				</rootfiles>
			</container>
			"""), zipfile.ZIP_DEFLATED)

		# One copy of stylesheet
		epub.writestr("stylesheet.css", self.epub_css().encode("utf-8"), zipfile.ZIP_DEFLATED)

		#---------------------------------------------
		# Start building Content Index
		#---------------------------------------------
		index_tpl = ET.Element(
			"{http://www.idpf.org/2007/opf}package",
			{	"version": "2.0",
				"unique-identifier": "bookid",
				},
			nsmap = {
				None:"http://www.idpf.org/2007/opf",
				"dc":"http://purl.org/dc/elements/1.1/"
				},
			)

		# Metadata about the book
		metadata = E.metadata()
		index_tpl.append(metadata)
		metadata.append(E("{http://purl.org/dc/elements/1.1/}title",self.title))
		metadata.append(E("{http://purl.org/dc/elements/1.1/}identifier",epub_uuid,{"id":"bookid"}))
		metadata.append(E("{http://purl.org/dc/elements/1.1/}language","en-US"))

		# File which gives the book structure
		manifest = E.manifest()
		index_tpl.append(manifest)
		manifest.append(E.item({
			"id":"css",
			"href":"stylesheet.css",
			"media-type":"text/css",
			}))
		manifest.append(E.item({
			"id":"ncx",
			"href":"toc.ncx",
			"media-type":"application/x-dtbncx+xml",
			}))

		spine = E.spine({"toc":"ncx"})
		index_tpl.append(spine)

		#---------------------------------------------
		# Split previously generated HTML and save
		# in multiple files. Add them to the manifest
		# and spine.
		#---------------------------------------------

		self.html_head.append(E.link({"type":"text/css","rel":"stylesheet","href":"stylesheet.css"}))

		remaining = list(self.html_body)
		i = 0
		while len(remaining) > 0:
			if self.opts.split_by_sections:
				chunk = E.body()
				chunk.append(remaining.pop(0))
				while len(remaining) > 0 and not (remaining[0].tag == "div" and remaining[0].attrib.get("id","").startswith("topsect")):
					chunk.append(remaining.pop(0))
			else:
				chunk = self.html_body
				remaining = []
		
			content_id = "content%d" % i
			content_filename = "content%d.html" % i	
			manifest.append(E.item({
				"id":content_id,
				"href":content_filename,
				"media-type":"application/xhtml+xml",
				}))
			spine.append(E.itemref({
				"idref":content_id
				}))

			html = E.html(self.html_head, chunk)
			html.attrib['xmlns'] = 'http://www.w3.org/1999/xhtml'
			html_elementtree = ET.ElementTree(element=html)

			text = '<?xml version="1.0" encoding="UTF-8"?>\n' \
				+ '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n' \
				+ ET.tostring(html_elementtree, encoding="utf-8", pretty_print=True)
			epub.writestr(content_filename, text, zipfile.ZIP_DEFLATED)

			i += 1

		#---------------------------------------------
		# Zip each embedded images and add it to
		# the manifest
		#---------------------------------------------
		i = 1
		for image in self.images:
			i += 1
			manifest.append(E.item({
				"id":"img-%d" % i,
				"href":image.filename,
				"media-type":image.mimetype,
				}))

			epub.writestr(image.filename, image.get_data(), image.compression)

		#---------------------------------------------
		# Zip content index and table of contents
		#---------------------------------------------
		epub.writestr("content.opf",
			ET.tostring(ET.ElementTree(element=index_tpl), encoding="utf-8", pretty_print=True),
			zipfile.ZIP_DEFLATED
			)
		epub.writestr("toc.ncx", self.epub_toc(epub_uuid), zipfile.ZIP_DEFLATED)

	def epub_css(self):
		# The base CSS stylesheet for ebook readers. Remember that
		# this is CSS 2.1, so no @media queries.
		css = textwrap.dedent("""\
			HTML, BODY, H1, H2, H3, H4, H4, P, UL, LI { margin: 0; padding: 0 }
			BODY { margin: 0.125in; font-size: 12pt }
			H1, H2, H3, H4, H4 { font-size: inherit }
			UL, OL { list-style-position: outside }
			LI, P { position: relative }
			TABLE { border-collapse: collapse }
			TH, TD { }
			HR.pagebreak { margin: 0.5in -0.5in 0.5in -0.5in }
			SPAN.space { white-space: pre-wrap }
			""")

		# Add the converted styles from the ODT file, again limited to CSS 2.1.
		css += "\n".join(self.styles.get_css(2.1))

		return css

	def epub_toc(self, epub_uuid):
		ncx = ET.Element(
			"{http://www.daisy.org/z3986/2005/ncx/}ncx",
			{	"version": "2005-1",
				},
			nsmap = {
				None:"http://www.daisy.org/z3986/2005/ncx/",
				},
			)

		ncx_head = E.head()
		ncx.append(ncx_head)
		ncx_head.append(E.meta({"name":"dtb:uid","content":epub_uuid}))
		ncx_head.append(E.meta({"name":"dtb:depth","content":"1"}))
		ncx_head.append(E.meta({"name":"dtb:totalPageCount","content":"0"}))
		ncx_head.append(E.meta({"name":"dtb:maxPageNumber","content":"0"}))

		ncx.append(E.docTitle(E.text(self.title)))

		ncx_navmap = E.navMap()
		ncx.append(ncx_navmap)

		i = 1
		for h_filename, h_id, h_text in self.h1s:
			print "  H1:", h_filename, h_id, h_text
			ncx_navmap.append(
				E.navPoint(
					E.navLabel(E.text(h_text)),
					E.content({"src":"%s#%s" % (h_filename, h_id)}),
					{	"id":"navpoint-%d" % i,
						"playOrder":"%d" % i
						},
					),
				)
			i += 1

		text = '<?xml version="1.0" encoding="UTF-8"?>\n' \
			+ '<!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd">\n' \
			+ ET.tostring(ET.ElementTree(element=ncx), encoding="utf-8", pretty_print=True)

		return text

	#============================================================================
	# Utility functions
	#============================================================================

	# Is this element empty of text and children?
	def element_empty(self, el):
		return el.text is None and el.tail is None and len(list(el)) == 0
	
	# Extract text from an ODT element and its children.
	# Throw away any formatting.
	def element_extract_text(self, el):
		text = ""
		if el.text is not None:
			text += el.text
		for child_el in el:
			text += self.element_extract_text(child_el)
		if el.tail is not None:
			text += el.tail
		return text
						
	# Convert an href which may have pointed to the ODT file to point
	# to the converted version instead.
	def href_to_html(self, href):
		return re.sub(r'\.odt$', '.html', href, flags=re.IGNORECASE)

	# Insert CSS styles into the head of the document.
	def add_css(self, css):
		style = E.style({"type": "text/css"})
		style.text = "\n" + re.sub(r"^\s*", r" ", css, flags=re.MULTILINE) + "\n"
		self.html_head.append(style)

#============================================================================
# These classes take ODF stylesheets and convert them to CSS stylesheets.
#============================================================================

# Represents a style rule
class CssStyle(object):
	def __init__(self, name):
		self.name = name			# name for ODF file
		self.template = None		# printf style template
		self.properties = {}		# what to put inside the curly brackets
		self.media = None			# media query condition
		self.used = False			# mentioned in document?
		self.simplified_td = False	# Have we dropt part of the name of a TD style?
		self.subst = None			# is this the same as some other style?
		self.break_before = None	# "page" for page break before
		self.language = None		# not CSS, but where else can we put this?
	def set_parent(self, parent):
		self.properties.update(parent.properties)
		self.media = parent.media
		self.break_before = parent.break_before
		self.language = parent.language
	def __unicode__(self):
		return "%s %s" % (self.template % self.className(), str(self.properties))
	def className(self):			# name converted to legal CSS class name
		return self.name.replace('.','_')
	def hashable(self):
		if self.simplified_td:
			return (self.template % self.className(), str(self.properties))
		else:
			return (self.template, str(self.properties))
	def get_text(self, css_version):
		style_text = "%s{%s}" % (
			self.template % self.className(),
			";".join(["%s:%s" % (name, value) for name, value in self.properties.items()])
			)
		if self.media is not None and css_version >= 3.0:
			style_text = "@media %s { %s }" % (
				self.media,
				style_text
				)
		return style_text

class CssListStyle(CssStyle):
	def __init__(self, name):
		CssStyle.__init__(self, name)
		self.tag = None
		self.levels = []
	def add_level(self, level, indentation):
		self.levels.append(indentation)
		assert len(self.levels) == level, "Incorrect levels in list style %s" % self.name
	def __unicode__(self):
		return "%s.%s: " % (self.tag, self.name) + ", ".join(self.levels)
	def hashable(self):
		return (self.tag, self.levels)
	def get_text(self, css_version):
		css_text = []
		css_text.append("%s.%s LI{margin-left:0;text-indent:0}" % (self.tag, self.name))
		count = 0
		for level in self.levels:
			css_text.append("%s.%s" % (self.tag, self.name) + (" %s" % self.tag) * count + "{padding-left:%s}" % level)
			count += 1
		return "\n".join(css_text)

class OdtStyle2Css(object):
	# Generic font names in ODF are different from those in CSS!
	font_family_map = {
		"roman":"serif",
		"swiss":"sans-serif",
		"modern":None,
		"script":"cursive",
		}

	def __init__(self, opts):
		self.opts = opts

		self.dimensions_re = re.compile("(^[-0-9\.]+)((in)|(pt)|(mm)|(cm)|(px))$")
		self.fonts = {}
		self.styles_ordered = []		# preserves original order (really necessary?)
		self.styles_byselector = {}		# by tag and class (for inclusion of parent styles)
		self.styles_byname = {}			# by name from ODT file
		self.styles_byhashable = {}		# for dedupping

	# When you find the <font-face-decls>, pass it to this function.
	def add_fonts(self, odt_font_face_decls):
		for font_face in odt_font_face_decls:
			name = font_face.attrib["name"]
			font_families = []
			if self.opts.font_support_level >= 2 and "font-family" in font_face.attrib:
				value = font_face.attrib["font-family"]
				font_families.append(value)
			if "font-family-generic" in font_face.attrib:	
				value = font_face.attrib["font-family-generic"]
				value = self.font_family_map.get(value, None)
				if value is not None:
					font_families.append(value)
			if "font-pitch" in font_face.attrib:
				value = font_face.attrib["font-pitch"]
				if value == "fixed":
					font_families.append("monospace")
			self.fonts[name] = ",".join(font_families)

	# When one of the styles tags (of which there are several) is found,
	# it is passed to this function.
	def add_stylesheet(self, odt_stylesheet):
		if self.opts.debug:
			print "===== Converting ODF Stylesheet ====="

		# Make first pass.
		dependent = []
		for style in list(odt_stylesheet):
			if not self.add_style(style):
				dependent.append(style)

		# Make a second pass to convert styles which had unresolved dependencies.
		for style in dependent:
			if not self.add_style(style):
				raise OdfInvalid("missing parent for style: %s %s" % (style.tag, style.attrib))

		if self.opts.debug:
			print

	# Take an ODF stylesheet tag and its children and add them to the HTML
	# document's CSS stylesheet.
	# Returns True if the style's dependencies (if any) were fulfilled and it
	# has been added to the HTML document's stylesheet.
	def add_style(self, odt_style):
		if self.opts.debug:
			print "  %s %s" % (odt_style.tag, odt_style.attrib)

		if odt_style.tag == "style":
			css_style = CssStyle(odt_style.attrib['name'])

			style_family = odt_style.attrib['family']
			if style_family == "text":
				css_style.template = "SPAN.%s"
			elif style_family == "paragraph":
				css_style.template = ".%s"	# P, H[12345], LI, or even TD
			elif style_family == "table":
				css_style.template = "TABLE.%s"
			elif style_family == "table-column":
				css_style.template = "COL.%s"
			elif style_family == "table-row":
				css_style.template = "TR.%s"
			elif style_family == "table-cell":
				simplifiable = True
				for el in odt_style:
					if el.tag == "table-cell-properties":
						vertical_align = el.attrib.get('vertical-align','middle')
						if vertical_align != 'middle':
							css_style.properties['vertical-align'] = vertical_align
							simplifiable = False
				if self.opts.simplify_table_borders and simplifiable:
					css_style.template = "TABLE.%s TD"
					css_style.simplified_td = True
					css_style.name = css_style.name.split(".")[0]	# drop the cell part of the name
				else:
					css_style.template = "TD.%s"
			elif style_family == "graphic":
				css_style.template = "IMG.%s"
				for el in odt_style:
					if el.tag == "graphic-properties":
						if el.attrib.get('vertical-rel') == 'baseline':
							pass
						else:
							horizontal_pos = el.attrib.get('horizontal-pos')
							if horizontal_pos in ('left', 'right'):
								css_style.properties['float'] = horizontal_pos
							#elif horizontal_pos == 'from-left':							# FIXME: what is this really supposed to do?
							#	css_style.properties['float'] = 'right'
							elif horizontal_pos == 'center':
								css_style.properties['display'] = 'block'
								css_style.properties['margin-left'] = 'auto'
								css_style.properties['margin-right'] = 'auto'
			elif style_family == "section":
				css_style.template = "DIV.%s"
			else:
				if self.opts.debug:
					print "    unimplemented style family: %s" % style_family
				return True

			# If this style has a parent, import its attributes.
			parent_style_name = odt_style.attrib.get("parent-style-name")
			if parent_style_name is not None:
				parent_style = self.styles_byselector.get((css_style.template,parent_style_name))
				if parent_style is None:
					if self.opts.debug:
						print "    deferring loading"
					return False
				css_style.set_parent(parent_style)

			# Process the <style:style>'s child elements.
			for el in odt_style:
				if self.opts.debug:
					print "    %s %s" % (el.tag, odt_style.attrib)
				if not el.tag.endswith("-properties"):
					if self.opts.debug:
						print "      unimplemented style child: %s" % el.tag
					continue

				# Convert properties which are generally applicable to block items.
				for prop in (
						"margin", "margin-left", "margin-right", "margin-top", "margin-bottom",
						"padding", "padding-left", "padding-right", "padding-top", "padding-bottom",
						"border", "border-left", "border-right", "border-top", "border-bottom",
					):
					if prop in el.attrib:						# If this attribute is defined,
						if not prop in css_style.properties:	# If not yet converted,
							value = el.attrib[prop]
							if value != "100%":					# don't know what 100% is supposed to mean, but it is poison...
								css_style.properties[prop] = self.clean_dimensions(value)

				# Convert percentage line height to multiplication factor because percentage
				# line height is inherited differently in ODF and in CSS.
				if "line-height" in el.attrib:
					value = el.attrib["line-height"]
					m = re.match(r'^(\d+)%$', value)
					if m:
						value = "%.2f" % (int(m.group(1)) / 100.0)
					css_style.properties["line-height"] = value
					

				# Text in blocks or inline
				if el.tag == "text-properties":
					if self.opts.font_support_level >= 1:
						font_name = el.attrib.get("font-name")
						if font_name is not None:
							font_family = self.fonts[font_name]
							if font_family != "":
								css_style.properties["font-family"] = font_family

					for prop in ("font-size", "font-style", "font-weight", "background-color"):
						if prop in el.attrib:
							css_style.properties[prop] = el.attrib[prop]

					# Stash language in CSS object
					if "language" in el.attrib:
						css_style.language = el.attrib["language"]

					# Drop black except on spans since we believe it is just noise.
					if "color" in el.attrib:
						color = el.attrib["color"]
						if color != "#000000" or style_family == "text":
							css_style.properties["color"] = color

					if "text-position" in el.attrib:
						m = re.match("^((super)|(sub)|(\d+%))( (\d+%))?$", el.attrib["text-position"])
						if not m:
							raise OdfNotImplemented("unrecognized text position: %s" % el.attrib["text-position"])
						else:
							vertical_align = m.group(1)
							font_scale = m.group(6)
							if font_scale is None:
								if vertical_align == "super" or vertical_align == "sub":
									font_scale = "60%"
							if vertical_align == "0%":
								print "  Warning: nested text-position in %s not converted correctly" % css_style.name
							else:
								css_style.properties["vertical-align"] = vertical_align
								if font_scale is not None:
									css_style.properties["font-size"] = font_scale

					if el.attrib.get("text-underline-style","none") != "none":
						css_style.properties["text-decoration"] = "underline"

					# FIXME: has side effect of canceling underlining
					if el.attrib.get("text-line-through-style","none") != "none":
						css_style.properties["text-decoration"] = "line-through"

				# To text blocks
				elif el.tag == "paragraph-properties":
					for prop in ("text-align", "text-indent", "background-color"):
						if prop in el.attrib:
							css_style.properties[prop] = el.attrib[prop]
					if "break-before" in el.attrib:
						css_style.break_before = el.attrib["break-before"]
						# Webkit uses non-standard attribute
						if el.attrib["break-before"] == "column":
							css_style.properties["-webkit-column-break-before"] = "always"
					if "border" in el.attrib:
						css_style.properties["border"] = el.attrib['border']

				elif el.tag == "table-properties":
					if "width" in el.attrib:
						width = el.attrib["width"]
						# If the table is wide enough to reach what are probably the margins,
						# assume the intent was to make it 100% wide.
						if self.dimension2points(width) > (7.0 * 72.0):
							css_style.properties["width"] = "100%"
						# Otherwise, use the stated width, but limit it to 100%.
						else:
							css_style.properties["max-width"] = width
							#css_style.properties["max-width"] = "calc(94%% - %s)" % css_style.properties.get("margin-left","0pt")
					# If no width was specified, it is explicitly a 100% wide table.
					else:
						css_style.properties["width"] = "100%"

				elif el.tag == "table-column-properties":
					if "column-width" in el.attrib:
						css_style.properties["width"] = el.attrib['column-width']

				elif el.tag == "table-row-properties":
					if "min-row-height" in el.attrib:
						css_style.properties["height"] = el.attrib['min-row-height']

				elif el.tag == "section-properties":
					for el2 in el:
						if el2.tag == "columns":
							for prop in ("column-count", "column-gap"):
								if prop in el2.attrib:
									css_style.media = "(min-width:8in)"
									css_style.properties[prop] = el2.attrib[prop]
									css_style.properties["-webkit-%s" % prop] = el2.attrib[prop]
									css_style.properties["-moz-%s" % prop] = el2.attrib[prop]

			# FIXME: read up on this. Does this attribute really indicate a new page?
			# NOTE: this will override the break-before in <paragraph-properties>
			if "master-page-name" in odt_style.attrib and odt_style.attrib["master-page-name"] != "":
				css_style.break_before = "page"

			# If we are simplifying table cell borders, make all four borders the
			# same by picking the last one listed which is not "none".
			if style_family == "table-cell" and self.opts.simplify_table_borders:
				for name, value in list(css_style.properties.items()):
					if name.startswith("border-"):
						del css_style.properties[name]
						if value != "none":
							css_style.properties["border"] = value

			if self.opts.debug:
				print "    -->%s" % unicode(css_style)

			# Add to list of all styles.
			self.styles_ordered.append(css_style)
	
			# For handling parent-style-name attribute
			self.styles_byselector[(css_style.template, css_style.name)] = css_style
	
			# If this style actually will appear in the CSS stylesheet,
			if not css_style.simplified_td:
				self.styles_byname[css_style.name] = css_style
	
			# If this style has the same right-hand-side as a style defined earlier,
			# note that that that earlier style could be used as a substitute to save
			# space in the HTML output file.
			hashable = css_style.hashable()
			css_style.subst = self.styles_byhashable.get(hashable)
			if css_style.subst is None:
				self.styles_byhashable[hashable] = css_style
				if css_style.simplified_td:
					css_style.used = True		# safe assumption?

		elif odt_style.tag == "default-style":
			# FIXME: not implemented
			# <style:default-style style:family="paragraph">
			#  <style:paragraph-properties fo:hyphenation-ladder-count="no-limit" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" sty
			#  <style:text-properties style:use-window-font-color="true" style:font-name="Liberation Serif" fo:font-size="12pt" fo:language="en" fo:country="
			# </style:default-style>
			pass

		# Partial implementation of List Styles
		# FIXME: one style is converted into a whole set
		elif odt_style.tag == "list-style":
			style_name = odt_style.attrib['name']
			previous_margin_left = 0.0
			css_style = CssListStyle(style_name)
			for el in odt_style:
				if el.tag == 'list-level-style-bullet':
					css_style.tag = "UL"
				elif el.tag == 'list-level-style-number':
					css_style.tag = "OL"
				else:
					raise OdfNotImplementedYet("Unsupported list-style element: %s" % el.tag)
				level = int(el.attrib['level'])
				#print "list %s level %d" % (css_style.name, level)	
				for el2 in el:
					if el2.tag == 'list-level-properties':
						for el3 in el2:
							if el3.tag == 'list-level-label-alignment' and el3.attrib.get('label-followed-by') == 'listtab':
								margin_left = self.dimension2points(el3.attrib['margin-left'])
								#print " margin-left:", margin_left
								css_style.add_level(level, "%.2fpt" % (margin_left - previous_margin_left))
								previous_margin_left = margin_left
								break
						else:		# presumably "space"
							css_style.add_level(level, "18pt")
							previous_margin_left += 18
						break
				else:
					OdfInvalid("list-style %s has not list-level-properties" % css_style.name)
				
			self.styles_ordered.append(css_style)
			self.styles_byname[css_style.name] = css_style

		else:
			if self.opts.debug:
				print "      unimplemented style tag: %s" % odt_style.tag

		return True

	# Used to determine whether a style has been simplified away.
	def style_still_exists(self, style_name):
		return style_name in self.styles_byname

	# Test whether the style has one or more attributes matching a wildcard expression.
	def test(self, style_name, pattern):
		if style_name is None:
			return False
		style = self.styles_byname.get(style_name)
		if style is None:
			return False
		return len(fnmatch.filter(style.properties.keys(), pattern))

	# The HTML generator calls this when it adds an element which uses a styles.
	# If the style exists, a note is made to include it in the CSS and the 
	# HTML class to use is returned. Otherwise, None is returned.
	def claim_style(self, style_name):
		if not style_name in self.styles_byname:
			if not style_name.startswith("M"):
				print "  Warning: style %s used but not defined" % style_name
			return None, None		# nix it
		css_style = self.styles_byname[style_name]
		if self.opts.collapse_styles and css_style.subst is not None:
			css_style = css_style.subst
		css_style.used = True
		return css_style.className(), css_style.language

	# For the wrapping tables hack
	def _by_css_class(self, css_class):
		if css_class is None:
			return None
		class_name = css_class.split(" ")[0].replace("_",".")
		if class_name == "":
			return None
		return self.styles_byname[class_name]

	def get_break_before(self, style_name):
		if not style_name in self.styles_byname:	# because we do not yet convert all styles
			return None
		return self.styles_byname[style_name].break_before

	# Return the converted styles as an array of CSS lines.
	def get_css(self, css_version):
		css = []
		for css_style in self.styles_ordered:
			if css_style.used or (not self.opts.drop_unused_styles):
				css.append(css_style.get_text(css_version))
		return css

	# Parse the right-hand side of a CSS style setting, find the numeric
	# dimensions and enforce a minimum size. In the process, all units
	# get converted to points.
	def clean_dimensions(self, style_arg):
		words = []
		for word in style_arg.split(" "):
			if self.dimensions_re.match(word):
				points = self.dimension2points(word)
				if points >= 0.8:
					word = "%.2fpt" % points
				elif points < 0.0001:
					word = "0pt"
				else:
					word = "thin"
			words.append(word)
		return " ".join(words)
	
	# Convert a CSS-style dimension with units into points.
	# We use this when making comparisons.
	def dimension2points(self, dimension):
		m = self.dimensions_re.match(dimension)
		if m:
			if m.group(2) == "pt":
				return float(m.group(1))
			elif m.group(2) == "in":
				return float(m.group(1)) * 72.0
			elif m.group(2) == "mm":
				return float(m.group(1)) * 72.0 / 25.4
			elif m.group(2) == "cm":
				return float(m.group(1)) * 72.0 / 2.54
			elif m.group(2) == "px":
				return float(m.group(1)) * 0.72			# about 100 DPI
		raise OdfNotImplementedYet("dimension not understood: %s" % dimension)

#============================================================================
# Images
#============================================================================
class Odt2HtmlImage(object):
	def __init__(self, odt, filename, svg2png):
		self.odt = odt
		self.filename = filename
		self.svg2png = svg2png

		if self.filename.endswith(".png"):
			self.mimetype = "image/png"
			self.compression = zipfile.ZIP_STORED
		elif self.filename.endswith(".gif"):
			self.mimetype = "image/gif"
			self.compression = zipfile.ZIP_STORED
		elif self.filename.endswith(".jpg"):
			self.mimetype = "image/jpeg"
			self.compression = zipfile.ZIP_STORED
		elif self.filename.endswith(".svg"):
			self.mimetype = "image/svg+xml"
			self.compression = zipfile.ZIP_DEFLATED
		else:
			raise OdfNotImplemented("Href extension not recognized: %s" % self.filename)

		self.original_filename = self.filename
		self.original_mimetype = self.mimetype

		if self.mimetype == "image/svg+xml" and self.svg2png:
			self.filename = "%s.png" % self.filename
			self.mimetype = "image/png"
			self.compression = zipfile.ZIP_STORED

	# Return image data as bytes
	def get_data(self, pretty_print=True):
		if self.original_mimetype == "image/svg+xml":
			if self.svg2png:
				import cairo
				import rsvg
				import StringIO
				svg = rsvg.Handle()
				svg.write(self.odt.open(self.original_filename).read())
				svg.close()
				width, height = svg.get_dimension_data()[:2]
				surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)
				svg.render_cairo(cairo.Context(surface))
				out_fh = StringIO.StringIO()
				surface.write_to_png(out_fh)
				return out_fh.getvalue()
			else:
				tree = ET.parse(self.odt.open(self.original_filename))
				for el in list(tree.iter()):
					self.prune_svg(el)
				return ET.tostring(tree, pretty_print=pretty_print, encoding="utf-8")	# yes, utf-8
		else:
			return self.odt.open(self.original_filename).read()

	def prune_svg(self, element):
		for key in element.attrib.keys():
			if key.startswith("{http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd}"):
				del element.attrib[key]
			elif key.startswith("{http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd}"):
				del el.attrib[key]
			elif key.startswith("{http://www.inkscape.org/namespaces/inkscape}"):
				del element.attrib[key]
		for child in list(element):
			#print child.tag
			if child.tag.startswith("{http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd}"):
				element.remove(child)
			if child.tag.startswith("{http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd}"):
				element.remove(child)
			elif child.tag.startswith("{http://www.inkscape.org/namespaces/inkscape}"):
				element.remove(child)
			elif child.tag == "{http://www.w3.org/2000/svg}metadata":
				element.remove(child)
			else:
				self.prune_svg(child)

#============================================================================
# TD Sound
#============================================================================

class LabelSoundFinder(object):
	def __init__(self, output_dirname, soundfile_basename):
		self.output_dirname = output_dirname
		self.base_url = urllib.quote(soundfile_basename)
		self.labels = []
		with codecs.open(os.path.join(self.output_dirname, "%s.txt" % soundfile_basename), "r", "utf-8") as f:
			for line in f:
				start, stop, text = line.rstrip().split("\t")
				assert re.match(r'^\d+\.\d+$', start)
				assert re.match(r'^\d+\.\d+$', stop)
				self.labels.append([text, "t=%s,%s" % (start, stop)])
	def find(self, text):
		if len(self.labels) > 0 and self.labels[0][0] == text:
			label = self.labels.pop(0)
			return "%s.ogg#%s" % (self.base_url, label[1])
		else:
			return None

class DirSoundFinder(object):
	def __init__(self, output_dirname, td_sound_dir):
		self.output_dirname = output_dirname
		self.td_sound_dir = td_sound_dir
		self.dup_counts = {}
	def find(self, text):
		text = text.replace(u"\u0301","")	# Remove stress marks.
		dup_count = self.dup_counts[text] = self.dup_counts.get(text,0) + 1
		for filename in (
				"%s/%s-%d" % (self.td_sound_dir, text, dup_count),
				"%s/%s" % (self.td_sound_dir, text),
				"%s/%s" % (self.td_sound_dir, text.replace("?",""))
				):
			if os.path.exists("%s/%s.ogg" % (self.output_dirname, filename)) and os.path.exists("%s/%s.mp3" % (self.output_dirname, filename)):
				#url = "%s/%s.ogg" % (self.output_dirname, filename)
				url = "%s.ogg" % filename
				return urllib.quote(url.encode("utf-8"))
		return None

#============================================================================
# Exceptions
#============================================================================

# We don't have this case covered
class OdfNotImplementedYet(Exception):
	pass

# We do know about this case, but do not plan to support it.
class OdfNotSupported(Exception):
	pass

# The input file looks corrupt
class OdfInvalid(Exception):
	pass

# Hyperlink with special target of "player" does not have the correct format.
class OdfBadPlayer(Exception):
	pass

# Formatting that will not translate well
class OdtBadFormatting(Exception):
	pass

#============================================================================
# Main
#============================================================================
if __name__ == "__main__":
	sys.stdout = codecs.getwriter('utf-8')(sys.stdout)
	sys.stderr = codecs.getwriter('utf-8')(sys.stderr)

	verbose = False
	force = False
	output_directory = None
	opts = Odt2HtmlOptions()
	while len(sys.argv) >= 2 and sys.argv[1].startswith("-"):
		if sys.argv[1] == "--debug":
			opts.debug = 1
			force = True
		elif sys.argv[1] == "--verbose":
			verbose = True
		elif sys.argv[1] == "--force":
			force = True
		elif sys.argv[1] == "--epub":
			opts.output_format = "epub"
		elif sys.argv[1] == "--snobject":
			opts.snobject = True
		elif sys.argv[1].startswith("--template="):
			opts.template = sys.argv[1][11:]
		elif sys.argv[1].startswith("--player-lib-dir="):
			opts.player_lib_dir = sys.argv[1][17:]
		elif sys.argv[1] == "-o":
			if len(sys.argv) >= 3:
				sys.argv.pop(1)	# -o
				output_directory = sys.argv[1]
			else:
				sys.stderr.write("Missing argument to -o\n")
				sys.exit(1)
		else:
			sys.stderr.write("Unrecognized option: %s\n" % sys.argv[1])
			sys.exit(1)
		sys.argv.pop(1)

	count_total = 0
	count_built = 0
	count_rebuilt = 0
	for filename in sys.argv[1:]:
		filename = filename.decode("utf-8")		# FIXME: why do we have to do this?
		if verbose:
			print u"\"%s\"" % filename
		filename_mtime = os.path.getmtime(filename)

		basename, ext = os.path.splitext(filename)
		if ext != ".odt":
			sys.stderr.write("Not an ODT file: %s\n" % filename)
			sys.exit(1)
		if output_directory is None:
			output_filename = "%s.%s" % (basename, opts.output_format)
		else:
			output_filename = os.path.join(output_directory, "%s.%s" % (os.path.basename(basename), opts.output_format))

		count_total += 1
		build = False
		if not os.path.exists(output_filename):
			if verbose:
				print "  building..."
			count_built += 1 
			build = True
		elif force or os.path.getmtime(output_filename) < filename_mtime:
			if verbose:
				print "  rebuilding..."
			count_rebuilt += 1
			build = True

		if build:
			if os.path.exists(output_filename):
				os.unlink(output_filename)

			gz_filename = "%s.gz" % output_filename
			if os.path.exists(gz_filename):
				os.unlink(gz_filename)

			# Perform the conversion
			try:
				Odt2Html(filename, output_filename, opts)
			except OdfNotImplementedYet as e:
				sys.stderr.write("ODF feature not implemented: %s\n" % unicode(e))
				sys.exit(1)
			except OdfNotSupported as e:
				sys.stderr.write("Change unsupported formatting: %s\n" % unicode(e))
				sys.exit(1)
			except OdfInvalid as e:
				sys.stderr.write("ODT file is invalid: %s\n" % unicode(e))
				sys.exit(1)
			except OdfBadPlayer as e:
				sys.stderr.write("Bad player variable: %s\n" % unicode(e))
				sys.exit(1)

			# Make the creation time of the HTML file one millisecond after the
			# creation time of the ODT file from which it was made.
			os.utime(output_filename, (filename_mtime + 0.01, filename_mtime + 0.01))
		elif verbose:
			print "    up-to-date"

	print "Built %d and rebuilt %d of %d files." % (count_built, count_rebuilt, count_total)

